# 数据仓库工具箱笔记
## 前言

* 这本书是维度建模的权威指南,但是由于书写的时间比较早,随着技术的不断更迭有些内容以及不适用了.不讨论当时技术在现在是否还适用,仅仅当经典概念来学习.
* 书中内容是根据不同的业务场景来逐步介绍维度模型的,这里总结就不按照书中的结构来记录了,仅仅记录自我认为比较合适的概念.
* 声明:本人是实习生,水平真的有限.酌情阅读,有理解错误欢迎指出.


## 基本概念了解

[基本概念](https://my.oschina.net/leejun2005/blog/188770)

## 1.初步认识 

### 数据获取和数据分析的区别

* 操作型系统保存数据;DW/BI使用数据.
* 操作型系统目的是更快的处理单个事务;DW/BI目的是更快的完成多个事务分析.
* 操作型系统不维护历史数据,只反映最新状态;DW/BI保存维护历史数据.

### 数据仓库的目标

* 易用性:简单,快捷.

> DW/BI系统的数据的内容易于理解,具有直观性,较短时间内将分析查询数据返回给用户.

* 一致性:数据必须就有一致性,具有一致性后才具有可信度.

> DW/BI系统的数据往往来自不同的数据源,需要进行一致性集成.

* 可变性:能够适应需求的变化.

> DW/BI系统要能够方便处理需求的无可避免的变化,在发生变化的时候仍能提供数据服务

* 支持决策:正确的支持决策.

> DW/BI最重要的输出是基于分析证据所产生的决策.注意,面向决策和面向财务的不同,面向决策是在一定程度上允许有误差的,面向财务则必须时刻准确.


### 维度建模简介

* 维度建模面向数据分析.
* 数据库中强调3NF,主要为了消除冗余.维度模型并不要求必须满足3NF.

#### 3NF模型和维度模型的区别

* 3NF模型
	* 规范化的3NF将数据划分为多个不同的实体,每个实体构成一个关系表
	* 大幅度减少数据冗余
	* 复杂度高,难以理解
	* 查询性能低
* 维度模型
	* 复杂度低,易于理解
	* 查询性能高
	* 灵活多变

#### 用于度量的事实表

* 事实表存储业务过程时间的性能度量结果.
* 尽量将来源于同一个业务过程的底层度量结果存储于一个维度模型中.
* 事实表示某个业务的度量.
* 事实表中的每行对应一个度量事件,同一张事实表中的所有度量行粒度相同.
* 度量数值类型
	* 可累加型事实,例如:销售额,可按照任意时间维度进行汇总.
	* 半可累加型事实,例如:账户余额,不能按照时间维度进行汇总,可按照时间均值.
	* 不可累加型事实,例如:单价.完全不能按照时间维度来做处理.
* 尽量不要将冗余文本信息(除唯一文本)放在事实表中,描述性冗余文本信息放入维度表中.对于事实表中的每个行来说,其文本都是唯一的.
* 不要将未发生的度量时间存入事实表.
* 事实表列少行多.
* 事实表类型
	* 事务型事实表
	* 周期快照型事实表
	* 累计快照型事实表
* 一般事实表具有多个外键与维度表的主键进行关联.
* 几个维度一起唯一标识一个事实表行.

#### 用于描述环境的维度表
* 维度表示度量时间的描述性信息.
* 维度表包含业务过程度量事件有关的文本环境.
* 维度表列多行少.
* 每个维度表由单一主键定义,用于在于事实表连接时作为参照完整性的基础.
* 数据库完整性:保证数据一致性,正确性,有效性
	* 参照完整性:要求关系中不允许引用不存在的实体.保证数据一致性和完整性.
	* 实体完整性:每个数据表必须有主键,唯一且非空.保证数据非空/唯一.
	* 域完整性:列必须满足某种特定的数据类型或约束.用户定义的完整性.
* 维度模型直接决定了数据仓库的好坏和OLAP的分析能力.
* 维度表通常具有层次关系,例如:日-周-月-年.这样做的目的是方便使用和提高查询性能.维度表通常不一定要满足第3范式,它常常是非规范化的,一个维度表往往存在多对一的关系.

#### 如何区分是维度还是事实?

* 描述性列
	* 该列数据是一种包含多个值并作为计算的参与者的度量,往往是事实.
		* 例如:产品的标价看起来像是一个产品的描述,但是它经常会发生变化,并且需要参与最终订单支付金额的计算,所以更可能是一种度量事实.
	* 该列是对具体值的描述,是一个常量/约束/行标识的参与者,往往是维度.
* 数字量
	* 连续值数字基本上可以任务属于事实.
	* 来自一个不太大的列表的离散数字基本可认为是维度属性.

#### 如何选择粒度

* 粒度最小的数据或原子数据具有最多的维度.尚未聚集的原子数据是最具有可表达性的数据.原子数据是构建能够满足用户提出任意查询的事实表的设计基础.同时也方便添加维度信息.

## 2.维度建模技术概要

### 4步骤维度设计过程
1. 选择业务过程:明确事实表要度量的事件是什么?
> 业务过程是由组织完成的微观活动.
> 
> 例如:获取订单,开具发票,学生注册,账户快照等
	* 业务过程特征
		1. 业务过程通常用行为动词表示,通常表示业务执行的活动
		2. 业务过程建立或获取关键性能度量
			* 建立关键性度量:学生注册,开具发票等
			* 获取关键性度量:获取订单,账户快照等
		3. 度量是业务过程的直接结果
		4. 一系列过程产生一些列事实表.

2. 声明粒度:定义事实表的每一行表示什么?
> 声明粒度意味着精确定义某个事实表的每一行表示什么.
> 
> 粒度传递的是与事实表度量有关的细节级别.
> 
> 例如:销售事务上每个销售订单一行,每个银行账户每个月一行.
	* 声明粒度是不容忽视的关键步骤,在构建维度模型前必须明确定义维度模型的粒度.
	* 粒度分为
		* 原子粒度
			* 能满足方便详细的维度建设
			* 能满足任何分析需求
			* 但是查询性能差
		* 聚合粒度
			* 限制了细节维度的建设
			* 无法下钻,分析有障碍
			* 查询性能好
	* 声明粒度最好以最低的原子粒度为基准.因为原子粒度具有强大的多维性
	* 也可以定义汇总粒度来表示对原子数据的聚集,但是一旦选择较高粒度就限制了建立更细节的维度的可能性,无法满足用户的下钻细节的需求.
	* 原子粒度和聚合粒度并不是互斥关系,可以构建原子粒度的企业一致性模型,然后在这基础上构建聚合粒度的模型.

3. 确认维度:怎么描述业务过程度量事件?
> 维度表示承担每个度量环境中所有可能的单值描述符.
> 
> 应当使用健壮的维度集合来描述事实表.
> 
> 常见的维度有:日期,用户等.

4. 确认事实:过程的度量是什么?
> 确定事实表度量的指标.
> 
> 设计中多有获选事实必须符合第2步粒度的定义.
> 
> 明显不同粒度的事实必须放在不同的事实表中.

![维度设计4步过程的关键输入](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/4步建模.jpg)

### 维表设计细节

> 维度提供围绕某一业务过程事件所涉及的"谁,什么,何处,何时,为什么,如何"等背景.

* 维度表包含BI应用所需要的用于过滤及分类事实的描述性属性.
* 当与事实表行关联时,任何情况下都应使维度保持单一值.
* 原子粒度维度模型对数据关系发生变化具有灵活的适应性.

#### 维度表代理建
* 维度表的唯一主键应该是代理建而不是来自操作型系统的标识符,也就是所谓的自然键.
* 代理键简单地以按照顺序序列生成的递增整数表示.
* 实际上代理键没有业务上的意义,仅仅用于连接维度表与事实表.
* 在做查询和数据访问应用时,不应该有任何与键的依赖关系.
* 使用代理键好处
	* 为数据仓库缓冲操作型系统的变化
	* 可以集成多个数据源
	* 改进性能:代理建是一个尽可能小的整数,而自然键则可能是庞大的数字/字母集合
* 使用代理键缺点
	* 生成费事,不如自然键直接使用方便
* 代理建生成

```sql
	#当前行号加上之前维度表的最大行数
	
	select row_number() + max_id, ... -- 因为代理建是简单递增,直接添加
	from ... t
	join(
		select max(id) as max_id from table
	) s --这里采用cross join
	
```

* 时间维度的智能键
	* 时间维度是可以预测的,所以可以在日期维度中使用更为智能的键
	* 日期维度的主键是一个有意义的整数

> 最好将时间维度的代理键设置为格式为YYYYMMDD.在事实表中,可以采用日期维度的外键进行过滤,提高过滤的可用行和性能.同样还可以将日期维度的智能键用于分区事实表,分区去报能够将表划分为更小的表.

* 通常不会给退化维度分配代理建.
* 事实表主键与维度表代理键不同,事实表主键采用代理建不可能获得查询性能的改进.所以一般事实表不采用代理建作为主键,采用直接的唯一标识即可.

#### 扁平多对一层次
* 维度表中每个不同层次都存在多对一关系,并且以扁平的形式存在于维度表中.

![产品维度示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/产品维度示例.jpg)

> 上图是产品维度的示例.产品维度描述仓库中存储的每个SKU(产品统一编码)的大多数描述性属性.每个属性都可以有层次.例如,图中每个SKU可以上卷到品牌,每个品牌可以上卷到类别,每个类别可以上卷到部门.每个不同层次都存在多对一的关系.(多个SKU对应一个层次).
> 
> 注意到商品维度的设计不是规范化的.例如,产品5-8子类描述全是Ice Cream.是不是设计错了?并不是这样.

#### 非规范化
* 维度表是带有重复文本的扁平非规范化的设计.
* 非规范化坏处
	* 数据冗余度高
	* 异常插入:新加入一个品牌但是没有SKU,就不能添加到表中你
	* 异常删除:删除一个SKU可能将该品牌值删光
	* 异常更新:每次更新都要更新多行
* 为什么维度表要设计成非规范化?
	* 对于事实表,维度表很小,数据规范节省空间效果甚微.
	* 非规范化值容易实现简单化与高性能
	* 维度模型主要关注易用性和性能的价值,而不是关注事务处理的效率

> 非规划化的缺点其实都是面向操作型系统的.操作型系统关注的是事务处理的速度,所以着重优化事务处理的过程.而维度表则关注的是数据分析,所以非规范化带来的异常增删改并没有对分析造成影响.在数据冗余方面,虽然非规范化带来的了少许数据的冗余,但是是可以接受的.相比较规范化导致分析数据的性能低和随之而来的抽象性,还是选择非规划化比较明智.

##### 具有规范化维度的雪花模型
* 规范化的维度表称为雪花模型.
* 冗余属性从扁平非规范化维度表中移除,放置于不同规范化的维度表中.

![产品维度雪花模型示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/产品维度雪花模型示例.jpg)

> 上图是产品维度雪花模型的实例,我们通过看图观察发现
> 
> 1.众多的雪花模型表构成了一个复杂的结果,违背了维度建模简单化的主要目标.
> 
> 2.大量的表和连接操作通常导致缓慢的查询性能.
> 
> 3.与雪花模式维度表有关的磁盘空间节省问题并不是非常明显.通过规范化维度表所节省的磁盘空间通常不会超过数据所需要空间的1%,
> 
> 4.雪花模式对用户浏览维度的能力有负面影响.

* 雪花模型虽然不推荐使用,但是也是维度建模的一个合法分支.
* 提倡采用固定深度层次在维度表中应该被扁平化,而不是规范化,牺牲掉规范化的冗余数据空间有利于改善性能和可用性.所谓用 空间 -> 易用性,性能

##### 雪花模型一部分的支架表
* 尽管不推荐使用雪花模型,但是在一些场景下是可以使用的.
* 但是不是意味着将整个模型规范化,而是将其中某个扁平化的多对一的层次规范化成支架表.

![产品维度支架表示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/产品维度支架表示例.jpg)

> 上图是产品维度日期支架表的示例

#### 属性层次
* 层次就是一系列多对一的关系.
* 层次分为
	* 固定层次
		* 例如日期层次: 天 -> 月 -> 年
		* 在固定位置的维度中,重要的是每个层次具有特定的名称,用户一看就知道如何约束并解释每个层次.应该避免在固定位置层次中使用抽象的名称.例如:级别1,级别2.
	* 非固定层次
		* 轻微不整齐的可变深度层次
			* 没有固定的层次深度,但层次深度有限
			* 例如:地理层次:地址 -> 区域 -> 城市 -> 省份,这里的区域是可以包含层级的,一级区域,二级区域...,
		* 不整齐可变深度层次
			* 深度不确定
			* 例如:公司组织结构
* 如何处理非固定层次问题
	* 轻微不整齐可变深度层次:合并微可变层次变成固定层次.例如:将所有区域放在一起当做一个区域层次.
	* 不整齐可变深度层次:建立桥接表

![组织桥接表示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/组织桥接表示例.jpg)

> 上图是组织桥接表的一个简单示例.在大公司组织中往往会存在不固定的上下部门组织之间的关系.在维度表中一个组织肯定对应一个层次.我们没有办法确定层次个数,所以只能采用桥接表的形式来辅助记录层次关系.我们看到事实表的组织外键并不是直接连到组织维度的代理键上,而是连接到桥接表.桥接表中记录了父子部门的层间关系(树形关系),以及所在位置信息,桥接表中的部门键才指向组织维度表.

* 如果,桥接表存在缓慢变化问题,我们可以采用维度缓慢变化的解决方式来解决.

![组织桥接拉链表示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/组织桥接拉链表示例.jpg)

> 上图是采用类型2来解决桥接表的变化问题.类似拉链表,添加上了生命周期.注意,生命周期结束的日期往往是下一个生命周期开始的日期,而不是真实结束的日期.为什么这么做?因为如果要是真的关注真实结束日期的话,就需要时时刻刻关注,一旦变化就更新桥接表.这样做即浪费时间还耗费精力,数据精度也没有提高多少.

#### 作为属性或事实的数字
* 某些数字值,很难判断应该将其归入维度属性分类,还是归入事实分类.

> 例如:产品的价格,因为商品的价格通常变化缓慢,不像其他事实表中的数量值,对一不同度量事件产生不同的值.那么商品价格是维度吗?

* 如果某个数字值主要用于计算或分析目的,他可能应该属于事实表.
* 如果某个数字值主要用于标识,分组,约束,他可能应该属于维度表.
* 如果数字值可同时用于计算以及过滤/分组功能,应该在事实表和维度表中同时存储.

> 标准价格主要用于计算最终订单支付总金额,或主要用于分析该商品的价格变化应该被存储在事实表中.如果能预先定义稳定的数字值,用于过滤和分组,则它应该被当成产品维度属性对待.如果标准价格同时被存储在事实表和维度表中,事实表中表示的是销售事务的价格,而维度属性则标识为指示当前情况的标准价格.

#### 维度的扩展
* 以最细粒度级别构建的维度,增加的维度可方便的应用,不必改变维度键或事实.
* 过早的聚集和汇总限制了增加补充维度的能力.
* 扩展能力
	* 新维度属性:可以把新属性作为新列增加进去.如果新属性仅在某个特定时间点可用,在老的维度行中将插入不可用或类似的描述.
	* 新维度:可在事实表上增加新维度,在事实表上增加新的外键列并将新维度的主键填写到该外键列上
	* 新可度量事实:如果新的可度量事实可用,可以将他们方便的增加到事实表上.事实表被改变,增加了新列,值被填充至表中.如果新事实仅在某个时间点可用,则将空值填充到旧事实表行中.
* 注意:粒度不同,不能进行到同一张表中.所以具有原子粒度的表是扩展性最好的表.

#### 日期维度
* 日期维度是一种特殊的维度,因为它几乎出现在所有的维度模型中.每个业务过程都需要获取时间序列的性能度量.
* 日期维度表示粒度按天处理的维度表,也就说时间维度的力度是天.
* 与多数其他维度不同,可以提前建立日期维度表.
* 日期维度表是相对较小的维度表.
* 日期维度表中的每列由行表示的特定日期定义.
* 日期维度的主键是特殊的智能主键,最好采用YYYYMMDD形式的整数格式.
* 日期维度可以包括过去和未来的日期.

![日期维度简单示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/日期维度简单示例.jpg)

> 上图是日期维度的简单示例.

* 为什么要有日期维度?
> 存在疑问的原因在于,如果事实表上的日期是日期类型的列,任何SQL查询可以直接约束事实表的时间键,利用SQL提供的日期语义进行过滤,从而可避免连接操作带来的使用性能.
>
> 但是,SQL日期函数不能支支持范围广泛的日期属性,包含周/财务周期/季节/假日/周末等等,与其试图将这些非标准日历计算放入查询中,不如放在日期维度表中,通过查询直接获得.日历逻辑由维度表解决,而不是由应用代码解决.所以,日期维度应尽可能的详细,维度模型也总是需要详尽的日期维度表.

* 大多数日期维度属性不应该更新.
* 大多数数据仓库按天加载数据.
* 最好以天为时间维度的粒度,如果需要精确的时间,应该用过时间戳来完成.
* 如果不需要对日期进行复杂的操作,可以退化放在事实表中.

#### 退化维度
* 操作型事务控制号码通常产生空的维度并且表示为事务事实表中的退化维度.
	* 例如:订单号码,发票号码,提货单号等.
* 当事实表粒度表示单一事务或事务列表时,退化维度比较常见.
* 退化维度通常在事实表的主键中起着重要的作用.
* 退化维度是没有对应维度表的维度键.
* 退化维度通常被保留作为操作型事务的标识符.

> 当一个维度值在不同事实中产生不同的度量,可以将该维度退化成为退化维度.

* 为什么要将事务单一的维度退化成为事实呢?
	* 因为维度表不应该与事实表一样以同样的速率增长.

#### 杂项维度
* 在建模复杂的操作型数据时,通常会遭遇大量五花八门的指标和标志,它们包含小范围的离散值.例如:支付类型.处理这些标志和指标的适当方法是将他们包装为一个或多个杂项维度.
* 杂项维度是对低粒度标志和指标的分组.
* 通过建立杂项维度,将标志和指标从事实表中移除,并将它们放到有用的多维框架中.
* 杂项维度可提供地方用于基于这些表示的约束和报表.事实与杂项维度之间存在一个单一的,小型的代理建.

![杂项维度示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/杂项维度示例.jpg)

> 上图是杂项维度的示例.支付类型/支付类型分组/订单类型等都是具有可数个数的标识维度.如果单独作为一个维度太小.所以进行合并成为杂项维度.一个完全的杂项维度是每个标识维度之间的笛卡尔积.

* 关于杂项维度的一个问题是:是否应该事先为所有组合的完全笛卡尔积建立行
 	* 应该估计杂项维度大概有多少种组合
 		* 组合数少时,可以预先建立起全完的杂项维度
 		* 组合数多时,当遇到未保存的杂项维度组合时新增杂项维度行.

#### 维度表的空值属性
* 当给定维度行没有被全部填充时,或者当存在属性没有被应用到所有维度行时,将产生空值维度属性.这种情况下,推荐采用描述性字符串代替空值.例如:Unknown,Not Applicable替换空值.
* 应该避免在维度表中使用空值.