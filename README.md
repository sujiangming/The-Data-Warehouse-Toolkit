# 数据仓库工具箱笔记
## 前言

* 这本书是维度建模的权威指南,但是由于书写的时间比较早,随着技术的不断更迭有些内容以及不适用了.不讨论当时技术在现在是否还适用,仅仅当经典概念来学习.
* 书中内容是根据不同的业务场景来逐步介绍维度模型的,这里总结就不按照书中的结构来记录了,仅仅记录自我认为比较合适的概念.
* 声明:本人是实习生,水平真的有限.酌情阅读,有理解错误欢迎指出.


## 基本概念了解

[基本概念](https://my.oschina.net/leejun2005/blog/188770)

## 1.初步认识 

### 数据获取和数据分析的区别

* 操作型系统保存数据;DW/BI使用数据.
* 操作型系统目的是更快的处理单个事务;DW/BI目的是更快的完成多个事务分析.
* 操作型系统不维护历史数据,只反映最新状态;DW/BI保存维护历史数据.

### 数据仓库的目标

* 易用性:简单,快捷.

> DW/BI系统的数据的内容易于理解,具有直观性,较短时间内将分析查询数据返回给用户.

* 一致性:数据必须就有一致性,具有一致性后才具有可信度.

> DW/BI系统的数据往往来自不同的数据源,需要进行一致性集成.

* 可变性:能够适应需求的变化.

> DW/BI系统要能够方便处理需求的无可避免的变化,在发生变化的时候仍能提供数据服务

* 支持决策:正确的支持决策.

> DW/BI最重要的输出是基于分析证据所产生的决策.注意,面向决策和面向财务的不同,面向决策是在一定程度上允许有误差的,面向财务则必须时刻准确.


### 维度建模简介

* 维度建模面向数据分析.
* 数据库中强调3NF,主要为了消除冗余.维度模型并不要求必须满足3NF.

#### 3NF模型和维度模型的区别

* 3NF模型
	* 规范化的3NF将数据划分为多个不同的实体,每个实体构成一个关系表
	* 大幅度减少数据冗余
	* 复杂度高,难以理解
	* 查询性能低
* 维度模型
	* 复杂度低,易于理解
	* 查询性能高
	* 灵活多变

#### 用于度量的事实表

* 事实表存储业务过程时间的性能度量结果.
* 尽量将来源于同一个业务过程的底层度量结果存储于一个维度模型中.
* 事实表示某个业务的度量.
* 事实表中的每行对应一个度量事件,同一张事实表中的所有度量行粒度相同.
* 度量数值类型
	* 可累加型事实,例如:销售额,可按照任意时间维度进行汇总.
	* 半可累加型事实,例如:账户余额,不能按照时间维度进行汇总,可按照时间均值.
	* 不可累加型事实,例如:单价.完全不能按照时间维度来做处理.
* 尽量不要将冗余文本信息(除唯一文本)放在事实表中,描述性冗余文本信息放入维度表中.对于事实表中的每个行来说,其文本都是唯一的.
* 不要将未发生的度量时间存入事实表.
* 事实表列少行多.
* 事实表类型
	* 事务型事实表
	* 周期快照型事实表
	* 累计快照型事实表
* 一般事实表具有多个外键与维度表的主键进行关联.
* 几个维度一起唯一标识一个事实表行.

#### 用于描述环境的维度表
* 维度表示度量时间的描述性信息.
* 维度表包含业务过程度量事件有关的文本环境.
* 维度表列多行少.
* 每个维度表由单一主键定义,用于在于事实表连接时作为参照完整性的基础.
* 数据库完整性:保证数据一致性,正确性,有效性
	* 参照完整性:要求关系中不允许引用不存在的实体.保证数据一致性和完整性.
	* 实体完整性:每个数据表必须有主键,唯一且非空.保证数据非空/唯一.
	* 域完整性:列必须满足某种特定的数据类型或约束.用户定义的完整性.
* 维度模型直接决定了数据仓库的好坏和OLAP的分析能力.
* 维度表通常具有层次关系,例如:日-周-月-年.这样做的目的是方便使用和提高查询性能.维度表通常不一定要满足第3范式,它常常是非规范化的,一个维度表往往存在多对一的关系.

#### 如何区分是维度还是事实?

* 描述性列
	* 该列数据是一种包含多个值并作为计算的参与者的度量,往往是事实.
		* 例如:产品的标价看起来像是一个产品的描述,但是它经常会发生变化,并且需要参与最终订单支付金额的计算,所以更可能是一种度量事实.
	* 该列是对具体值的描述,是一个常量/约束/行标识的参与者,往往是维度.
* 数字量
	* 连续值数字基本上可以任务属于事实.
	* 来自一个不太大的列表的离散数字基本可认为是维度属性.

#### 如何选择粒度

* 粒度最小的数据或原子数据具有最多的维度.尚未聚集的原子数据是最具有可表达性的数据.原子数据是构建能够满足用户提出任意查询的事实表的设计基础.同时也方便添加维度信息.

## 2.维度建模技术概要

### 4步骤维度设计过程
1. 选择业务过程:明确事实表要度量的事件是什么?
> 业务过程是由组织完成的微观活动.
> 
> 例如:获取订单,开具发票,学生注册,账户快照等

	* 业务过程特征
		1. 业务过程通常用行为动词表示,通常表示业务执行的活动
		2. 业务过程建立或获取关键性能度量
			* 建立关键性度量:学生注册,开具发票等
			* 获取关键性度量:获取订单,账户快照等
		3. 度量是业务过程的直接结果
		4. 一系列过程产生一些列事实表.

2. 声明粒度:定义事实表的每一行表示什么?
> 声明粒度意味着精确定义某个事实表的每一行表示什么.
> 
> 粒度传递的是与事实表度量有关的细节级别.
> 
> 例如:销售事务上每个销售订单一行,每个银行账户每个月一行.

	* 声明粒度是不容忽视的关键步骤,在构建维度模型前必须明确定义维度模型的粒度.
	* 粒度分为
		* 原子粒度
			* 能满足方便详细的维度建设
			* 能满足任何分析需求
			* 但是查询性能差
		* 聚合粒度
			* 限制了细节维度的建设
			* 无法下钻,分析有障碍
			* 查询性能好
	* 声明粒度最好以最低的原子粒度为基准.因为原子粒度具有强大的多维性
	* 也可以定义汇总粒度来表示对原子数据的聚集,但是一旦选择较高粒度就限制了建立更细节的维度的可能性,无法满足用户的下钻细节的需求.
	* 原子粒度和聚合粒度并不是互斥关系,可以构建原子粒度的企业一致性模型,然后在这基础上构建聚合粒度的模型.

3. 确认维度:怎么描述业务过程度量事件?
> 维度表示承担每个度量环境中所有可能的单值描述符.
> 
> 应当使用健壮的维度集合来描述事实表.
> 
> 常见的维度有:日期,用户等.

4. 确认事实:过程的度量是什么?
> 确定事实表度量的指标.
> 
> 设计中多有获选事实必须符合第2步粒度的定义.
> 
> 明显不同粒度的事实必须放在不同的事实表中.

![维度设计4步过程的关键输入](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/4步建模.jpg)

### 维表设计细节

> 维度提供围绕某一业务过程事件所涉及的"谁,什么,何处,何时,为什么,如何"等背景.

* 维度表包含BI应用所需要的用于过滤及分类事实的描述性属性.
* 当与事实表行关联时,任何情况下都应使维度保持单一值.
* 原子粒度维度模型对数据关系发生变化具有灵活的适应性.

#### 维度表代理建
* 维度表的唯一主键应该是代理建而不是来自操作型系统的标识符,也就是所谓的自然键.
* 代理键简单地以按照顺序序列生成的递增整数表示.
* 实际上代理键没有业务上的意义,仅仅用于连接维度表与事实表.
* 在做查询和数据访问应用时,不应该有任何与键的依赖关系.
* 使用代理键好处
	* 为数据仓库缓冲操作型系统的变化
	* 可以集成多个数据源
	* 改进性能:代理建是一个尽可能小的整数,而自然键则可能是庞大的数字/字母集合
* 使用代理键缺点
	* 生成费事,不如自然键直接使用方便
* 代理建生成

```sql
	#当前行号加上之前维度表的最大行数
	
	select row_number() + max_id, ... -- 因为代理建是简单递增,直接添加
	from ... t
	join(
		select max(id) as max_id from table
	) s --这里采用cross join
	
```

* 时间维度的智能键
	* 时间维度是可以预测的,所以可以在日期维度中使用更为智能的键
	* 日期维度的主键是一个有意义的整数

> 最好将时间维度的代理键设置为格式为YYYYMMDD.在事实表中,可以采用日期维度的外键进行过滤,提高过滤的可用行和性能.同样还可以将日期维度的智能键用于分区事实表,分区去报能够将表划分为更小的表.

* 通常不会给退化维度分配代理建.
* 事实表主键与维度表代理键不同,事实表主键采用代理建不可能获得查询性能的改进.所以一般事实表不采用代理建作为主键,采用直接的唯一标识即可.

#### 扁平多对一层次
* 维度表中每个不同层次都存在多对一关系,并且以扁平的形式存在于维度表中.

![产品维度示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/产品维度示例.jpg)

> 上图是产品维度的示例.产品维度描述仓库中存储的每个SKU(产品统一编码)的大多数描述性属性.每个属性都可以有层次.例如,图中每个SKU可以上卷到品牌,每个品牌可以上卷到类别,每个类别可以上卷到部门.每个不同层次都存在多对一的关系.(多个SKU对应一个层次).
> 
> 注意到商品维度的设计不是规范化的.例如,产品5-8子类描述全是Ice Cream.是不是设计错了?并不是这样.

#### 非规范化
* 维度表是带有重复文本的扁平非规范化的设计.
* 非规范化坏处
	* 数据冗余度高
	* 异常插入:新加入一个品牌但是没有SKU,就不能添加到表中你
	* 异常删除:删除一个SKU可能将该品牌值删光
	* 异常更新:每次更新都要更新多行
* 为什么维度表要设计成非规范化?
	* 对于事实表,维度表很小,数据规范节省空间效果甚微.
	* 非规范化值容易实现简单化与高性能
	* 维度模型主要关注易用性和性能的价值,而不是关注事务处理的效率

> 非规划化的缺点其实都是面向操作型系统的.操作型系统关注的是事务处理的速度,所以着重优化事务处理的过程.而维度表则关注的是数据分析,所以非规范化带来的异常增删改并没有对分析造成影响.在数据冗余方面,虽然非规范化带来的了少许数据的冗余,但是是可以接受的.相比较规范化导致分析数据的性能低和随之而来的抽象性,还是选择非规划化比较明智.

##### 具有规范化维度的雪花模型
* 规范化的维度表称为雪花模型.
* 冗余属性从扁平非规范化维度表中移除,放置于不同规范化的维度表中.

![产品维度雪花模型示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/产品维度雪花模型示例.jpg)

> 上图是产品维度雪花模型的实例,我们通过看图观察发现
> 
> 1.众多的雪花模型表构成了一个复杂的结果,违背了维度建模简单化的主要目标.
> 
> 2.大量的表和连接操作通常导致缓慢的查询性能.
> 
> 3.与雪花模式维度表有关的磁盘空间节省问题并不是非常明显.通过规范化维度表所节省的磁盘空间通常不会超过数据所需要空间的1%,
> 
> 4.雪花模式对用户浏览维度的能力有负面影响.

* 雪花模型虽然不推荐使用,但是也是维度建模的一个合法分支.
* 提倡采用固定深度层次在维度表中应该被扁平化,而不是规范化,牺牲掉规范化的冗余数据空间有利于改善性能和可用性.所谓用 空间 -> 易用性,性能

##### 雪花模型一部分的支架表
* 尽管不推荐使用雪花模型,但是在一些场景下是可以使用的.
* 但是不是意味着将整个模型规范化,而是将其中某个扁平化的多对一的层次规范化成支架表.

![产品维度支架表示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/产品维度支架表示例.jpg)

> 上图是产品维度日期支架表的示例

#### 属性层次
* 层次就是一系列多对一的关系.
* 层次分为
	* 固定层次
		* 例如日期层次: 天 -> 月 -> 年
		* 在固定位置的维度中,重要的是每个层次具有特定的名称,用户一看就知道如何约束并解释每个层次.应该避免在固定位置层次中使用抽象的名称.例如:级别1,级别2.
	* 非固定层次
		* 轻微不整齐的可变深度层次
			* 没有固定的层次深度,但层次深度有限
			* 例如:地理层次:地址 -> 区域 -> 城市 -> 省份,这里的区域是可以包含层级的,一级区域,二级区域...,
		* 不整齐可变深度层次
			* 深度不确定
			* 例如:公司组织结构
* 如何处理非固定层次问题
	* 轻微不整齐可变深度层次:合并微可变层次变成固定层次.例如:将所有区域放在一起当做一个区域层次.
	* 不整齐可变深度层次:建立桥接表

![组织桥接表示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/组织桥接表示例.jpg)

> 上图是组织桥接表的一个简单示例.在大公司组织中往往会存在不固定的上下部门组织之间的关系.在维度表中一个组织肯定对应一个层次.我们没有办法确定层次个数,所以只能采用桥接表的形式来辅助记录层次关系.我们看到事实表的组织外键并不是直接连到组织维度的代理键上,而是连接到桥接表.桥接表中记录了父子部门的层间关系(树形关系),以及所在位置信息,桥接表中的部门键才指向组织维度表.

* 如果,桥接表存在缓慢变化问题,我们可以采用维度缓慢变化的解决方式来解决.

![组织桥接拉链表示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/组织桥接拉链表示例.jpg)

> 上图是采用类型2来解决桥接表的变化问题.类似拉链表,添加上了生命周期.注意,生命周期结束的日期往往是下一个生命周期开始的日期,而不是真实结束的日期.为什么这么做?因为如果要是真的关注真实结束日期的话,就需要时时刻刻关注,一旦变化就更新桥接表.这样做即浪费时间还耗费精力,数据精度也没有提高多少.

#### 作为属性或事实的数字
* 某些数字值,很难判断应该将其归入维度属性分类,还是归入事实分类.

> 例如:产品的价格,因为商品的价格通常变化缓慢,不像其他事实表中的数量值,对一不同度量事件产生不同的值.那么商品价格是维度吗?

* 如果某个数字值主要用于计算或分析目的,他可能应该属于事实表.
* 如果某个数字值主要用于标识,分组,约束,他可能应该属于维度表.
* 如果数字值可同时用于计算以及过滤/分组功能,应该在事实表和维度表中同时存储.

> 标准价格主要用于计算最终订单支付总金额,或主要用于分析该商品的价格变化应该被存储在事实表中.如果能预先定义稳定的数字值,用于过滤和分组,则它应该被当成产品维度属性对待.如果标准价格同时被存储在事实表和维度表中,事实表中表示的是销售事务的价格,而维度属性则标识为指示当前情况的标准价格.

#### 维度的扩展
* 以最细粒度级别构建的维度,增加的维度可方便的应用,不必改变维度键或事实.
* 过早的聚集和汇总限制了增加补充维度的能力.
* 扩展能力
	* 新维度属性:可以把新属性作为新列增加进去.如果新属性仅在某个特定时间点可用,在老的维度行中将插入不可用或类似的描述.
	* 新维度:可在事实表上增加新维度,在事实表上增加新的外键列并将新维度的主键填写到该外键列上
	* 新可度量事实:如果新的可度量事实可用,可以将他们方便的增加到事实表上.事实表被改变,增加了新列,值被填充至表中.如果新事实仅在某个时间点可用,则将空值填充到旧事实表行中.
* 注意:粒度不同,不能进行到同一张表中.所以具有原子粒度的表是扩展性最好的表.

#### 日期维度
* 日期维度是一种特殊的维度,因为它几乎出现在所有的维度模型中.每个业务过程都需要获取时间序列的性能度量.
* 日期维度表示粒度按天处理的维度表,也就说时间维度的力度是天.
* 与多数其他维度不同,可以提前建立日期维度表.
* 日期维度表是相对较小的维度表.
* 日期维度表中的每列由行表示的特定日期定义.
* 日期维度的主键是特殊的智能主键,最好采用YYYYMMDD形式的整数格式.
* 日期维度可以包括过去和未来的日期.

![日期维度简单示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/日期维度简单示例.jpg)

> 上图是日期维度的简单示例.

* 为什么要有日期维度?
> 存在疑问的原因在于,如果事实表上的日期是日期类型的列,任何SQL查询可以直接约束事实表的时间键,利用SQL提供的日期语义进行过滤,从而可避免连接操作带来的使用性能.
>
> 但是,SQL日期函数不能支支持范围广泛的日期属性,包含周/财务周期/季节/假日/周末等等,与其试图将这些非标准日历计算放入查询中,不如放在日期维度表中,通过查询直接获得.日历逻辑由维度表解决,而不是由应用代码解决.所以,日期维度应尽可能的详细,维度模型也总是需要详尽的日期维度表.

* 大多数日期维度属性不应该更新.
* 大多数数据仓库按天加载数据.
* 最好以天为时间维度的粒度,如果需要精确的时间,应该用过时间戳来完成.
* 如果不需要对日期进行复杂的操作,可以退化放在事实表中.

#### 退化维度
* 操作型事务控制号码通常产生空的维度并且表示为事务事实表中的退化维度.
	* 例如:订单号码,发票号码,提货单号等.
* 当事实表粒度表示单一事务或事务列表时,退化维度比较常见.
* 退化维度通常在事实表的主键中起着重要的作用.
* 退化维度是没有对应维度表的维度键.
* 退化维度通常被保留作为操作型事务的标识符.

> 当一个维度值在不同事实中产生不同的度量,可以将该维度退化成为退化维度.

* 为什么要将事务单一的维度退化成为事实呢?
	* 因为维度表不应该与事实表一样以同样的速率增长.

#### 杂项维度
* 在建模复杂的操作型数据时,通常会遭遇大量五花八门的指标和标志,它们包含小范围的离散值.例如:支付类型.处理这些标志和指标的适当方法是将他们包装为一个或多个杂项维度.
* 杂项维度是对低粒度标志和指标的分组.
* 通过建立杂项维度,将标志和指标从事实表中移除,并将它们放到有用的多维框架中.
* 杂项维度可提供地方用于基于这些表示的约束和报表.事实与杂项维度之间存在一个单一的,小型的代理建.

![杂项维度示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/杂项维度示例.jpg)

> 上图是杂项维度的示例.支付类型/支付类型分组/订单类型等都是具有可数个数的标识维度.如果单独作为一个维度太小.所以进行合并成为杂项维度.一个完全的杂项维度是每个标识维度之间的笛卡尔积.

* 关于杂项维度的一个问题是:是否应该事先为所有组合的完全笛卡尔积建立行
 	* 应该估计杂项维度大概有多少种组合
 		* 组合数少时,可以预先建立起全完的杂项维度
 		* 组合数多时,当遇到未保存的杂项维度组合时新增杂项维度行.

#### 维度表的空值属性
* 当给定维度行没有被全部填充时,或者当存在属性没有被应用到所有维度行时,将产生空值维度属性.这种情况下,推荐采用描述性字符串代替空值.例如:Unknown,Not Applicable替换空值.
* 应该避免在维度表中使用空值.建立空值的维度行,用于处理无维度情况.

#### 处理缓慢变化维度(SCD)属性
* 尽管维度表属性相对稳定,但它们不可能是一成不变,尽管相当缓慢,属性值仍然会随时间发生变化.
* 缓慢变化维度(Slowly Changing Dimension,SCD)

##### 类型0:保留原始值
* 标记位类型0的维度属性值绝对不会变化,因此事实始终按照该原始值分组.
* 类型0适合任何标记位原始的属性,例如原始信用分值等历史不会发生变化的维度信息.

##### 类型1:重写
* 对缓慢变化维度类型来说,对其影响需要重写维度行中的就值,以当前值覆盖替换.
* 属性始终反映最近的情况.
* 类型1响应是应对维度变化的最简单的方法.
	* 仅需要以当前值重写先前存在的值.
	* 不需要触碰事实表.
* 类型1存在的问题是将会失去属性变化的所有历史记录,因为重写删除了历史属性值,仅保存了当前最新的属性值.
* 适用于对属性变化并不是很在意或不需要保存过去的描述的场景.
* 类型1响应易于实现,但是无法保留属性值的历史值,违背了数据仓库的一个特性:反映历史.在属性变化前后可能会产生不同的结果.
* 在维度发生变化的时候,收到影响的的聚集表需要重新组织重写.

##### 类型2:增加新行(拉链表),反映历史变化
* 使用类型2方法,在维度发生变化时,新的维度行将被插入到维度表中应对维度变化.

![缓慢维度变化问题-类型2](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/缓慢维度变化-类型2.jpg)

> 上图是用类型2来解决维度变化问题.在示例中,因为部门名称发生变化,则新建立一行最新的数据维度行插入到原表中.

> 当维度表包含类型2属性时,应该为每行增加几个方便管理的列.生命周期指示行:生命周期开始时间,生命周期结束时间.添加时间.当前行是否有效指示标志.
> 
> 有效日期和失效日期支持对维度的精确的时间分片.有效日期行是描述事务有效的第一天.当首次加载到维度表时,失效日期被设置为9999-12-31,应该避免失效日期为空值.
> 
> 当新行添加到维度表中以获取类型2属性变化时,先前的行过期了,通常建议旧行的结束日期等于新行的有效日期,不要在这些有效日期和失效日期间留下时间间隔.通常,有效日期和失效日期通常表示变化是按天度量的.如果要跟踪更细的时间粒度应该关注与该行的添加和更新时间戳.

* 缓慢变化维度类型2响应需要使用代理键,而不是自然键.
* 发生类型2变化时,事实表仍没有被改变;不需要修改历史事实表行,只需要在新维度变化后的事实中引用新维度的代理键即可.
* 类型2响应是**精确跟踪缓慢变化维度属性**的主要技术.因为新维度行能够自动划分事实表的历史,这是一种非常好的技术.
* 类型2可以说是拉链表.具体拉链表的使用请见[拉链表简介](https://blog.csdn.net/xiepeifeng/article/details/42431027)  [拉链表ETL](http://lxw1234.com/archives/2015/08/473.htm)

##### 类型3:增加新属性,反映历史关联
* 类型2响应能够区分历史情况,但是无法确保能够将新属性值与过去的历史事实关联.因为类型2在事实使用新的维度属性的时候并没有对旧属性的相关记录.

> 类型2无法解决这样的需求:当销售地区边界被重新划分.对新的销售地区维度采用类型2的解决方式.有些用户希望能够按照先前地区上卷最近的销售情况,以观察对比新的的地区的销售情况.

* 维度发生变化前后新旧值,使用类型3响应的话,不需要建立新维度行,仅需要增加新列以获取属性变化.

![缓慢维度变化问题-类型3](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/缓慢维度变化-类型3.jpg)

> 上图是类型3的示例,在部门名称发生变化时,需要更改维度行中的当前部门名称和先前部门名称,不需要添加新的维度行.

* 类型3缓慢变化维度技术能够确保要么通过新的,要么通过旧的属性值来考察新的事实表和历史事实表,有时候也被成为交换的现实.
* 类型3很少被使用,因为不能够解决不可预测的属性变化.
* 类型3最时候应用于当某个变化影响维度表中大量行(整体维度重构)的情况,例如部门重组.整体发生变化是使用类型3的主要场景,因为业务用户通常希望能够比较当前和先前层次下组织在一段时期的度量.采用类型3变化,先前列将被标记以明显地表示变化前的分组.

##### 类型4:微型维度,解决维度快速变化
* 上面我们关注的是维度表的缓慢变化的问题,如果变化率加快时,特别是针对大型的维度表如果采用类型2则会产生巨大的维度表.这类维度的容量对浏览和查询性能具有负面影响.我们不希望在包含大量行的维度表上增加更多的行,特别是面对变化频繁发生的情况.
* 采用不同的维度消除频繁分析或频繁变化的属性,这一维度技术称为微型维度.
* 微型维度的创建时通过将一部分不稳定的属性从主维度中移出,并将他们放置到拥有自己代理键的新表中来实现的.这些属性相互之间没有直接关联,不存在自然键,是通过为每个组合创建新行的一次性过程来加载数据的.

> 用户维度中,用户的注册日期/性别/身份证/年龄等属性是基本上不会发生变化的.但是用户VIP等级/用户信用等级会随着用户的行为不断发生变化.将容易发生变化的属性从主维度表中移出,放到一个新的维度表中.新的维度表中的数据行并不是每个用户一行,而是按照移出的维度属性的所有枚举值进行笛卡尔积加载而成的.新的维度表中并没有自然键,也不能使用自然键,应该使用代理键.

* 微型维度具有局限性.微型维度是事先用所有可能值的组合加载的,需要考虑每个属性的基数,且最好是枚举值.很多属性可能是非枚举值也同样变化很快.
* 微型维度虽然很少的保证了主维度的稳定性,但是破坏了维度的可浏览性.

> 如果是非枚举值,可以将不断变化的属性转化为带状范围值.宽度范围集合需要与业务人员商量进行预先制定,这样能够将未知且离散的属性值转化为已知的范围值存储,还能大大减低微型维度的大小.
> 
> 注意:微型维度一般都是提前建立好的.

![带状微型维度](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/带状微型维度.jpg)

* 注意:微型维度虽然是在大维度表中抽取出来的不稳定维度,但微型维度并没有与大维度表进行关联,而是与事实表进行关联.如果与大维度表进行关联同样没有解决维度变化过快问题,只是简单的将维度分开.如果与事实表关联则是将微型维度里的维度视为'退化维度'处理,事实表的增长则不会影响到大维度表,因为变化的属性值被分开到微型维度,而微型维度中也没有随着事实表增长而增长,因为是枚举组合,直接应用可能值的代理键即可.

![微型维度](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/微型维度.jpg)

##### 分区解决维度变化

* 这是询问公司大佬,他们原公司的解决方式.每天都全量导入维度表.每天一个分区.如果有相关历史维度需求则可以联合使用分区数据来完成.但是这种方式实现简单,使用方便,但是存在的问题是变化维度固定为天,一些精细的历史变化分析需求无法满足.

#### 维度角色扮演
* 当同一维度同时被当成单一事实表中的不同角色,这种情况成为角色扮演.
* 当某个维度在单一事实表中同时出现多次时,则会存在维度模型的角色扮演.
* 基本谁度可能作为单一物理表存在,但是每种角色应该被当成标识不同的视图展现到BI工具中.

![日期维度角色扮演](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/日期维度角色扮演.jpg)

> 上图是日期维度角色扮演的实例,日期维度被当做两个角色与事实表进行关联.与日期维度来说,订单日期维度和请求发货日期维度是根据日期维度建立的不同名字的视图.



### 事实表设计细节

#### 事实表结构
* 从最低的粒度级别来看,事实表行对应一个度量事件.
* 事实表的设计完全依赖于物理活动,不受可能产生的最终报表的影响.
* 除数字度量外,事实表总是包含外键,用于关联与之相关的维度,也包含可选的退化维度键和日期/时间戳.

#### 可加/半可加/不可加事实
* 事实表中的数字度量可划分为三类
	* 可加性度量:可以按照与事实表关联的任意维度汇总.最灵活,最有用的的事实是完全可加的.
	* 半可加度量:可以对某些维度汇总,不能对所有维度汇总.例如库存,可以按照地点和商品进行汇总,而按照时间维度把库存累计起来则毫无意义.记录静态水平(库存水平,金融余额)的所有度量针对日期维度天然居委非可加性.在此情况下,度量可以跨日期按照时间周期**求平均**来聚集.
	* 不可加事实:完全不可加的,例如比率.对于不可加的事实尽量将不可加性事实可分解为可加性事实.不可加事实通过分解的事实进行计算.例如优惠率,应该分解为订单原价金额与订单优惠金额两个事实存储在事实表中.

#### 事务事实表
* 事实事实表的一行对应空间或时间上某点的度量事件.
* 事务事实表可以是稠密的,也可以是稀疏的,仅当存在度量时才会建立行.
* 度量数字事实必须与事务粒度保持一致.
* 事务型业务过程是最常见的业务过程.
	* 原子事务事实表的粒度可在事务环境下简洁的描述,每个事务一行或每个事务线一行.
	* 通常比较稀疏,事务事件发生时间随机.
	* 可能十分庞大
	* 事务事件返回的度量通常都是可加的
* 设计事务事实表之前,估计事实表的行数是非常有必要的.

#### 周期性快照事实表
* 周期快照事实表中的每行汇总了发生在某一标准周期,如某一天/某周/某月的多个度量事件.
* 粒度是周期性的,而不是个体的事务.
* 周期快照事实表通常包含许多半可加事实,任何与事实表粒度一致的度量事件都是被允许存在的.
* 周期性快照事实表是稠密的,即使周期内没有活动发生,也会在事实表中为每个事实度量插入包含0的行.
* 周期性快照事实表的事实是根据时间周期和业务选定维度来确定度量的.只要周期和维度一致即可存在于一个快照性事实表中.

#### 累积快照事实表
* 累积快照事实表的行汇总了发生在过程开始和结束之间可预测步骤内的度量事件.
* 累积快照表示具有确定的开始和结束时间以及在此期间所有中间过程步骤的过程,累积快照最适合处理业务用户开展对工作流或流水流的分析.
* 通常在事实表中针对过程中的关键步骤都包含日期外键,表示可预期的主要事件或过程里程碑.
* 当过程开始时在累积快照事实表中建立一行,当管道过程发生变化时,累积事实表行被访问并修改.

> 由于累积快照通常表示效率和工作流或流水线经过的时间,事实表通常包含表示关键里程碑之间延迟或持续时间的度量.使用事务事实通常难以回答持续时间问题,因为需要关联行以计算持续时间.有时持续时间度量的仅仅是里程碑日期之间行的差异,或日期/时间戳之间行的差异.

* 累计快照事实表有时包含里程碑完成计数,其值要么是0,要么是1.
* 累计快照通常包含一个状态维度的外键,用于更新状态维度以反映流水线的最新状态.
* 累积快照与周期快照不同,周期快照保留了先前的快照,累积快照仅仅反映当前状态和度量.对孤立点的分析一般利用事务事实表来完成.

#### 如何选择事实表?

![三种事实表对比](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/三种事实表对比.jpg)

* 某一特定的动作,以活动为最小单位的粒度,选择事务事实表.
	* 例如:下单/付款/发货/成功/入库/出库/检验等等.
* 某一实体对象在当前时间上的状况选择快照事实表.
	* 长周期,无状态转化的,无明确的生命周期的事务度量在某个固定的,可预测的事件间隔内的累计性能选择周期性快照事实表.
		* 例如:库存/账户余额等等.
	* 短周期,有状态转化,有短暂的生命周期(具有明确的开始时间和结束时间以及中间步骤)的事务度量工作流的性能选择累计性快照事实表.
		* 例如:订单交易/商品检验等等.

#### 无事实的事实表
* 事实表用事实来度量业务过程,不包含事实或度量的事实表称为无事实的事实表.
* 多数度量时间获取的结果是数字化的,但是也存在某些事件仅仅记录一系列某一时刻发生的多维实体.例如:学生选课的业务过程,没有可记录的数字化事实,但该事实行带有一个包含日期/学生/教师/课程/地点等维度外键.
* 利用无事实的事实表可以分析发生的事件过程.

#### 聚集型事实表(汇总表)
* 聚集事实表是对原子粒度事实表数据进行简单的数字化上卷操作,目的是提高查询性能.
* 聚集事实的构建是通过对来自多个原子事实表的度量的汇总而获得的.通过访问聚集数据,可以减少数据库在响应查询是必须执行的工作量,能够快速响应用户的查询,同时有利于减少不同用户访问明细数据带来的结果不一致问题.
* 聚集型事实表一般被放在公共汇总层.
* 聚集型事实表设计原则
	* 必须提供与查询明细粒度数据一致的查询结果
	* 不要在同一个表中存储不同层次的聚集数据
	* 聚集并不需要保持与原始明细粒度数据一样的粒度,聚集只关心所需要查询的维度
	* 聚集的事实都是原始模型的事实,聚集的维度也需要时原始模型维度中的维度
* 聚集的维度和度量必须与原始模型保持一致,聚集是不跨事实的.跨事实的横向钻取一般采用合并事实表.

#### 合并事实表(宽表)
* 将来自多个过程的,以相同粒度表示的事实合并为单一的合并事实表.
* 合并事实表特别适合惊颤更需要共同分析的多过程度量.

#### 蜈蚣事实表
* 事实表的维度过多,被称为蜈蚣事实表.
* 应该避免蜈蚣事实表.

> 一些设计者为多对一层次的每层建立不同的规范化维度,例如日期维度/月份维度/季度维度等,并将所有外键包含在一个事实表中.这将产生蜈蚣事实表,包含于维度相关的多个维度.应该避免使用蜈蚣事实表.所有这些固定深度的,多对一层次化关联的维度都应该回到他们最细节的粒度上,例如上面提到的日期,应该收纳为日期维度中多层次维度.
> 
> 当设计者将多个外键嵌入到单一低粒度维度表中,而不是建立杂项维度,也会产生蜈蚣事实表.

![蜈蚣事实表](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/蜈蚣事实表.jpg)

> 上图是蜈蚣事实表的一个示例,我们发现许多维度都可以被合并成为一个多层次的维度模型.例如,日期相关的所有维度都能合并成为以日期天为粒度的多层次日期维度.

* 大量的维度通常表明某些维度不是完全独立的,应该合并为一个维度.将同一层次的元素表示为事实表中的不同维度是维度建模中常见的错误.


### 总线架构
* 企业数据仓库总线架构提供一种建立企业DW/BI系统的增量是方法.通过关注业务过程,将过程分解,通过重用跨不同过程的标准化一致性维度发布实现集成.
* 总线是一种常见的连接一切的公共结构,所有事情从总线获取能量.
* 通过为DW/BI环境定义标准总线接口,不同组可以在不同时间实现不同的维度模型.如果采用同样的标准,则不同的业务过程主题区域汇集在一起并有效共存.而总线架构就是起到了标准的作用.
* 企业总线仓库总线架构提供了一种了解企业DW/BI规划任务的合理方法.标准化维度和事实的主要套件在整个企业中有统一的解释.通过他们建立数据结构框架,可以处理不同的以过程为中心的维度模型的实现,所以实现严格遵守公共结构.
* 总线架构实际遵循一致性维度和事实.

#### 价值链
* 价值链表标明了组织主要活动的,自然的,逻辑的流程.
* 操作型原系统通常在价值链的每个步骤建立事务或快照.多数分析型DW/BI系统的主要目标是监控关键步骤的性能结果.因为每个步骤以唯一时间间隔,唯一的粒度和维度产生唯一的度量,所以每个过程通常包含一个或多个事实表.

![价值链示例.jpg](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/价值链示例.jpg)

> 上图是库存的价值链示例,价值链主要记录了库存的主要流程.

#### 总线矩阵
* 企业数据仓库总线矩阵是用于设计并与企业数仓库总线架构交互的基本工具.
* 总线矩阵可以很好的描述总线架构.
* 通过价值链抽象出需要监控的关键步骤,这个关键步骤就是业务过程.业务过程表示为矩阵的列.
* 总线矩阵的列表示整个企业的公共维度,这样的列通常有助于创建核心维度列表,之后填充矩阵用于评价给定的维度是否应该与某个业务过程关联.
* 矩阵中的点表示维度与给定的业务过程是否存在关联关系.

![零售总线矩阵](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/零售总线矩阵.jpg)

> 上图是零售行业的总线矩阵,行表示的是需要关注的业务过程,列表示的是公共维度.使用共享的公共维度对实际集成的维度模型至关重要.使用公共维度加大了ETL难度,需要对不同业务过程的相同维度进行抽象,还需要对不同维度间的权衡.


#### 一致性维度
* 当不同的维度表的属性具有相同列名和领域内容时,称维度表具有一致性.
* 一致性维度指的是完全一样的维度,一般采用公共共享维度来解决一致性问题,可以被所有事实表重用.
* 一致性维度共享跨企业过程的事实表.一致性维度也被成为公共维度,主维度,引用维度和共享维度.
* 除了保证事实度量的一致性和可用性,一致性维度还能够确保将来自不同业务过程的性能度量合并到单个报表中.
* 从最基础的层面来看,一致性维度以为着每个可能存在的事实表在连接时具有相同的连接属性.相等的一致性维度具有一致性的维度键,属性列名,属性定义和属性值.
	* 例如:同样是日期维度,在一个维度表中是中文月,另一个维度表中是英文月.这样的维度属性是不一致的.
* 多数一致性维度自然的定义为尽可能最低的粒度级别.需要不同业务共同使用某鞋公共属性名称,定义和值来统一和集成数据.

> 一致性维度的范围是总线架构中的维度,可能在多个集市中出现.在同一个集市中,一致性维度是如果两个维度有关系,要么完全一样,采用公共的一致性维度;要么一个维度是另一个维度的子集.例如,如果建立月维度的话,月维度各种描述必须和日期维度中完全一致.最常用的做法就是在日期维度上建立视图生成月维度.

#### 一致性事实
* 一致性事实指的是事实度量完全一致
	* 度量的命名一致
	* 度量的定义一致
	* 度量计算方式一致
	* 度量单位一致

> 如果某些度量出现在不同的事实表中,需要注意,如果需要比较或计算不同事实表中的事实,应该保证针对事实的技术定义是相同.如果不同的事实表定义是一致的,则这些一致性事实应该具有相同的命名,如果他们不兼容,则应该有不同的命名用于区分.

#### 一致性维度/一致性事实共同保证仓库的一致性
* 一致性维度将多个数据集市结合在一起.
* 一致性事实保证不同数据集市间事实可交叉探查.

#### 总线架构/一致性维度/一致性事实是维度建模的三个重要性概念




# 数仓命名规范
## 表命名规范

![表命名规范](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/表命名规范.jpg)

> 数据库表名命名规定:单词之间分割是用_来进行分割,字符全部小写
> 
> 表名第一部分:仓库分层,也就是表所在的仓库中的哪一层.
> 
> 表名第二部分:业务域.如果公司比较大,下面有很多子公司,业务域可以以子公司来进行命名区分.如果仅是一个单一公司,还可以使用不同部门名字或者以产品线业务模块来进行命名划分.
> 
> 表名第三部分:数据域.一般都以产品线的功能点去划分的.例如:交易域,订单域,用户域,画像域,社区域等等.具体还分业务场景.
> 
> 表名第四部分:业务描述.用精炼的单词或者拼音来描述这个表是做什么的.这部门一定要凝练好语句,不然容易给别人造成误导.
> 
> 表名第五部分:数据周期+存储策略.目前针对数据仓库进行的数据周期一般是根据时间维度来划分的.例如:年/季度/月/周/日/小时.一般低于小时粒度不会采用批处理来做,要采用实时计算框架.存储策略:常用的增量存储或者全量存储.
> 

## 字段命名规范

### 属性字段/维度字段
* 属性字段命名,直接采用文本字段,使用通用单词描述字段含义即可.例如:订单支付状态:order_status.订单ID:order_id

### 统计类型字段
* 计数字段: <计数主体>_cnt
* 比例字段: <计数主体>_rate
* 费用字段: <计数主体>_amt
* 排名字段: <计数主体>_rank
* 平均字段: <计数主体>_avg_xxx

### 时间类型字段
* 时间字段: <业务主体>_time
* 日期字段: <业务主体>_date

### 分区类型字段
* 分区字段: partition_<分区主体>

### 标识字段
* 标识字段: is_<标识主体>

### 指标字段
* 指标字段分为:原子指标和派生指标.派生指标是由原子指标/时间周期修饰词和若干其他修饰词组合得到的.

* 原子指标命名规则: 动作 + 度量
	* 例如: pay_amt, 支付的费用
* 派生指标命名规则: 修饰词 + 原子指标词 + 时间修饰词
	* 例如: card_pay_amt_1d, 昨天银行卡支付的费用.其中的修饰词为card; 原子指标为pay_amt;时间修饰词为1d.

* 在构建派生指标的时候要注意
	* 上下层即派生指标同时存在时,例如最近1天支付金额和最近1天PC端支付金额,建议使用前者,把PC端作为维度属性放在物理表中体现.
	* 父子关系原子指标存在时,派生指标使用子原子指标创建派生指标.例如PV,IPV(详情页PV),当统计商品详情页PV时,优先选择子原子指标IPV.



# 数据模型构建

## 构建流程

![数据模型构建流程](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/数据模型构建流程.jpg)

> 上图是阿里巴巴的onedata的数据实施工作流程.

 
## 准备工作

### 数据调研:理解业务/收集需求
> 
> 我们在构建数据仓库之前,要进行数据调研.数据调研最重要的是对业务的理解和对业务需求的收集.数据仓库模型算是业务驱动.只有更好的满足了业务需求,数据仓库的建设才有意义.
> 
> 

### 明确业务域/划分数据域/找出业务过程

> 明确业务域,一般业务域都是由产品线/功能线来区分的.
> 
> 然后就是数据域的划分.数据域是指面向业务分析,将业务过程或者维度进行抽象的集合.业务过程可以概括为一个个不可拆分的行为事件.例如下单/支付/退款.为保证整个体系的生命力,数据域需要抽象提炼,并且长期维护和更新,但不轻易变动.在划分数据域是,既能涵盖当前所有的业务需求,又能在新业务进入时无需影响地被包含已有的数据域中或者扩展新的数据域.数据域中包含很多原子型的业务过程.我们可以按照产品功能模块/业务总线划分数据域,然后进行将数据域下的业务过程明确.
> 

![明确业务动作](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/明确业务动作.jpg)

> 上图是明确业务过程的示例.当我们划分了业务线/功能模块,我们通过使用APP功能/网页功能就能列出所有有的业务动作,每个业务动作就是一个业务过程.
> 

![明确业务过程](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/明确业务过程.jpg)

> 然后根据列举出的所有业务动作来确定业务过程.我们这里每列举的业务动作都是一张/多张事实表,例如库存可以产生库存流水表(事务事实表),库存快照表(周期快照事实表).在列举业务动作的过程中,我们需要额外关注涉及到的维度.挑选公共的维度用于建设一致维度模型.


## 设计阶段

### 构建总线矩阵

> 
> 构建总线矩阵.
> 
> 矩阵的行是准备工作中提炼的业务过程,矩阵的列是公共维度.这里的公共维度是共享维度/核心维度.数据仓库总线架构的重要基石之一就是一致性维度.
> 
> 总线矩阵的构建是数据仓库建设的基础.总线矩阵保证了一致性维度的设计理念.

![采购总线矩阵示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/采购总线矩阵示例.jpg)

[总线矩阵设计注意事项](https://www.jianshu.com/p/b3353d137261)

#### 总线矩阵实践

![社区电商总线矩阵示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/社区电商总线矩阵示例.jpg)

> 上图是我自己设计的社区电商的总线矩阵.数据域划分采用的业务板块划分的策略进行划分的,总共划分为两大块:电商和社区.在电商模块业务过程采用的是交易流程的下每个子过程.在社区模块业务过程捕捉的是用户的社区行为.
> 
> 注意:买家和卖家和用户的区分.买家和卖家都是用户的角色扮演,是抽取的功能视图.而鉴定师则不是角色扮演,因为存在业务逻辑问题:鉴定师不一定是用户.
> 
> 在日期维度,因为都是采取的日的日期维度.所以在总线矩阵中就没有标注,如果有特殊需求,需要周/月/年等等需要额外标注.
> 
> 上面列举维度有上架单/购买单/交易单/快递单,这种类型的维度数据一般都是唯一的,我们在做的时候需要将其退化成事实存在事实表中.

### 维度设计
* 维度是维度建模的基础和灵魂.维度用于分析事实所需要的多样环境.
* 维度所包含的标识维度的列,称为维度属性.维度属性是查询约束条件/分组和报表标签生成的基本来源,是数据易用性的关键.维度的作用一般是查询约束/分类汇总以及排序等等.


#### 维表特征1:唯一主键

* 维度使用主键标识其唯一性,维度主键是确保与之相连的任何事实表之间存在应用完整性的基础.
* 主键有两种:代理键和自然键.如何选择
> 如果存在多源数据推荐使用代理键.代理键就是一个简单的递增数字没有任何意义,是个简单的递增整数序列就可以了.
> 
> 如果仅仅是个单一源头的数据,导入到数据仓库中就能保证每条数据ID的唯一性,那么使用原始数据ID的自然键作为主键就可以了,方便省事快捷.
> 


#### 维表特征2:非规范化层次结构
* 维度中的一些描述属性以层次方式或一对多的方式相互关联,可以理解为包含连续主从关系的属性层次.层次的最底层代表维度中描述最低级别的详细信息,最高层代表最高级别的概要今夕.维度常常有多个这样的嵌入式层次结构.例如:商品维度有:商品/行业/一级类目/二级类目/品牌等等.商品属于类目,类目输入行业,二级类目属于一级类目.非规范化的维度模型称为星型模型.

![非规范化商品维度示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/非规范化商品维度示例.jpg)

* 规范化的维度叫雪花模型,会将扁平化的层次结构拆分成为一个子维度,也就是维度表在嵌套维度表.是一个立体的维度,不是扁平化的.采用规范化维度表可以减少冗余数据.但是增加了关联性能.

 ![规范化商品维度示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/规范化商品维度示例.jpg)

* 对于规范化维度来说,虽然减少了冗余数据,但是增加了关联性能.适用于OLTP,在面向事务型的系统里能发挥最大功效.对于非规范化的维表来说,扁平化的设计虽然会带来异常插入/删除的问题.但是数据仓库中数据是稳定的,不涉及插入删除,主要用于数据分析OLAP,采用非规范化维度表简单直观,性能高.采用星型模型,仅仅带给数据仓库就是节约微不足道的存储空间.其他没有任何效用.

> 异常删除:删除一项数据可能需要删除上百上千条数据.也可能删除光.
> 
> 异常插入:新添加一个未有参与数据的数据项,不能直接体现.

#### 维表问题1:维度表整合和拆分问题

##### 整合
1. 保证多个表中的命名规范和字段规范统一
2. 对业务含义相同的表集成
	1. 主从表:将多个表中共有的字段放在主表,从属信息放在各自的从表中
	2. 直接合并:共有信息和个性信息都放在一起.如果表中的重合度较低,则会出现大量空值.
	3. 不合并:自己保存自己的.

##### 拆分
1. 公共维度和个性维度拆分
	* 公共维度集成一张维度表,个性维度为扩展子表.

2. 热点维度和非热点维度
	* 热点维度划分为主表,非热点维度划分为子表.

3. 稳定维度和不稳定维度
	* 稳定维度划分为主表,不稳定/变化快的维度划分为子表.

#### 维表问题2:缓慢维度变化问题
1. 重写维度指:直接覆盖.丢失历史信息.
2. 插入新的维度行:历史拉链表,存在历史信息,一般以天为变化粒度,以start_date和end_date作为分区.不能将变化前后记录的事实归一位变化前的维度或者归一为变化后的维度.
3. 添加维度列:保存历史信息,有明确数据变化前后的联系.只适用于稳定次数的变化.
4. 快照维度.每天给维度表打一个全量快照.简单有效,但是浪费存储空间.

#### 维表问题3:快速维度变化问题
1. 维度拆分:将稳定的维度和不稳定的维度进行拆分,保证主维度的稳定性.
2. 微型维度:将可枚举变化快的维度属性单拉出来当做一个独立维表.注意,单拉出的变化较快的维度并不是维度表的支架表,而是直接连接事实表的,类似于'退化维度',直接与事实相连.

#### 维表问题4:递归层次问题
1. 浅层次转化为固定层次
2. 深层次采用桥接表,存储上一级和所在级的对应关系(父-子).位于事实表与维度表之间.

### 基本设计方法
1. 选择维度或新建维度.必须保证维度的唯一性,有且只有一个维度定义.
2. 确定主维表.此处的主维表一般是ODS表,直接与业务系统同步.一般维度都可在ODS中找到.例如:商品维度表的主维表肯定是与业务系统同步的商品信息表.
3. 确定相关维表.根据对业务的梳理,确定哪些表和主维表存在关联关系,并选择其中某些表生成维度属性.例如:商品维度表确定了商品信息表是主维表,然后要收集他所有的外连表,然后进行退规范化为扁平化处理.
4. 确定维度属性.从主维表和相关维表中选择属性构建维度表.

> 注意:
> 
> 1. 尽可能生层丰富的维度属性,为下游的数据统计/数据分析/探查提供良好的基础.
> 
> 2. 尽可能多给出包括一些富有意义的文字描述.在关系模型中,很多信息都是编码外键化.在维度模型中,我们不应该只存储对应的编码,这样会让使用者难以理解.最好将编码化信息转化成简单易懂的描述类信息.或者编码与描述同时存在.例如:商品ID,商品名称,类目ID,类目描述.
> 
> 3. 区分数值型属性和事实.一般用于查询约束条件或分组统计的是维度属性.一般参加度量计算的为事实.例如:商品价格,用于查询统计价格区间的商品数量是维度属性.用于计算GMV,所有商品平均价格时当事实使用.
> 
> 4. 尽量沉淀出通用的维度属性.
> 

#### 维度表设计实践

* 在维度表设计过程中,只要找出主维度表,相关维度表也会被找出,然后进行扁平化.

 ![商品维度表示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/商品维度表示例.jpg)

> 上图是商品维度表的一个示例.
> 
> 主要步骤:先确定主维度表:kk_product商品信息表.商品信息表位于ODS层.kk_product是业务库过来的表,是规范化的表,表中存在大量外键.然后我们继续手机外键表.收集到的表有品牌表/类目表/尺码表/发售日期表/等等,让后将所有外键关联表进行规整到一张维度表中.外键名字要重新定义:<外键主体>_id,然后将所有描述信息收集.构成商品维度表.
> 

### 事实表设计

#### 事实表种类
1. 事务事实表:描述业务过程,保存最原子的数据.
2. 周期快照事实表:具有规律性,可遇见时间间隔记录事实
3. 累计快照事实表:表述过程开始和结束之间的关键步骤时间,覆盖过程的整个生命周期,通常有多个里程碑时间.

#### 事实表度量种类
1. 可加性度量:可按照任意维度进行汇总.例如:GVM,PV,UV等.
2. 半可加性度量:可按照特定维度进行汇总.例如:库存,账户余额等.按照时间汇总无任何意义,但是可以按照时间平均.
3. 不可加性度量:不具备可加性.例如:比率型事实.一般需要将不可加性事实分解成为可加性的事实.例如:订单优惠率应该拆分成为订单原价和订单优惠金额两个可加性事实存储在事实表中.

#### 设计原则
1. 尽可能包含所有与业务过程相关的事实.即使出现冗余,也是数字类型,不会浪费很多空间.
2. 只选择与业务过程相关的事实.例如:在商品下单这个业务过程中不应该出现支付金额这个业务过程的事实.
3. 分解不可加性事实为可加组件.
4. 在选择维度和事实之间必须先声明粒度.声明粒度是事实表设计中不可忽视的重要的一步.粒度用于确定事实表中一行所代表业务的细节层次.在声明粒度后,事实表每行的粒度应该与声明的粒度保持一致.建议从原子粒度开始,因为原子粒度具有最大的灵活性.
5. 在同一事实表中不能有多种不同粒度的事实.
6. 事实表的单位要保持一致.最好使用整数.例如订单的金额,订单的优惠金额.金额最好以分为单位,避免使用浮点数.同时还要同一所有事实表的单位.
7. 对事实的null进行处理.建议用0值填充.
8. 使用退化维度提高事实表的易用性.


#### 事实的设计准则
1. 事实完整性:事实表包含与其描述的过程有关的所有事实,尽可能多的获取所有的度量.
2. 事实一致性

> 在确定事务事实表的事实时,明确存储每一个事实以保证度量的一致性.度量一致性包括:数据来源一致,单位一致,计算过程一致.如果不能保证度量一致性,那么事务度量的命名应加以区分,不能使用相同命名.

3. 事实可加性:事实表确定事实时,尽量将非可加性度量拆解成为可加性的组件,下游关注的更多的也是可加性事实,下游聚合统计时也更加方便.

#### 事务事实表设计方法

1. 选择业务过程

> 在明确了业务需求后,需要对需求进行详细的分析,对业务的整个生命周期进行分析,明确关键的业务步骤,从而选择与需求有关的业务过程.
> 
> 业务过程通常使用行为动词表示业务执行的活动.
> 
> 一般在明确业务后,就要分析业务的流转过程.从业务的流转过程中抽取业务过程.注意业务过程通常都是一种行为动作.
> 
> 
 
![交易订单流转拆解业务过程示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/交易订单流转拆解业务过程示例.jpg)

> 在选择了业务过程后,相应的事实表类型也随之确定了.如果只包含一个业务过程一般都是会采用事务事实表.例如:单买家付款业务流程,用事务型事实表记录付款动作.如果选择多个业务,一般采用累积事实表.例如:用累积事实表记录订单流转整个过程.

2. 声明粒度

> 声明粒度是事实表建模非常重要的一步,意味着精确定义事实表的每一行所表示的业务含义.声明粒度的过程其实意味着声明主键.
> 
> 一张事实表只能存在一种粒度.应该尽量选择最细级别的原子粒度,以保证事实表的应用具有最大的灵活性.例如:交易订单流转的每个业务过程的粒度应该为子订单粒度,而不是订单粒度.因为业务中一个订单中可能包含多个子订单.所以原子粒度应该为子订单.
> 

3. 确定维度

> 完成粒度声明后,也就意味着确定了主键,对应的维度组合以及先关维度字段就可以确定了.例如:粒度是子订单.子订单是主键,那么相关的维度有:买家/卖家/商品/收货人信息/业务类型/订单时间.

4. 确定事实

> 确定事实可以通过回答 "过程的度量是什么?" 来确定.应该选择与业务过程有关的所有事实,且事实的粒度要与所声明的事实表的粒度一致.如果是不可累加型事实要拆解成可加组件.例如:订单付款这个业务过程产生的度量有:子订单分摊的支付金额/邮费/优惠金额/商品数量等等.
>

5. 冗余维度

> 在kimball维度建模理论中,提倡缩减事实表的列到通过外键到维度表中以减少数据的冗余,减少存储消耗.但是现在计算资源比存储资源珍贵,所以我们现在尽力要提高用户的使用效率,尽量减少不必要的表关联.所以通常会冗余方便下游用户使用的常用维度到事实表中.例如:商品维度的商品名/商品类目/店铺信息等等都会被冗余到事实表中.
> 

![淘宝交易事务事实表](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/淘宝交易事务事实表.jpg)


![冗余维度后淘宝交易事务事实表](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/冗余维度后淘宝交易事务事实表.jpg)

> 上面是对淘宝交易的累计事务事实表进行维度冗余.进行维度冗余后,一般需求我们就可以不用进行维表关联直接使用事实表就可以了.

##### 多事务事实表

* 如果多个业务过程常用维度一致,并且拥有相同的事务粒度.那么可以将这多个业务过程集成为一个多事务事实表.
* 区分多事实事实表的多个业务过程事实有两种方法:
	* 在多事实事实表中,不同业务过程的事实使用不同的事实字段进行存放.非本业务过程事实字段用零值填充.
	* 不同业务过程的事实使用同一个事实字段进行存放,但是要增加一个业务过程标签标识是哪个业务过程.

* 当不同业务过程的度量比较相似,差异不大时,可以采用多事务事实表.如果不同业务过程中度量差异较大那么最好采用单事务事实表.
* 多事务事实表相比与单事务的事实表来说,难以理解但是减少了不同业务过程的维度数据的冗余,每个单个事务表都要冗余一次,多事务表仅只冗余一次.

##### 无事实的事务事实表
* 一些业务过程是没有事实产生的,仅仅是多个维度的在某个时间点的汇集.例如:学生选课,商品收藏等业务过程.

#### 周期快照事实表设计
* 事务事实表课可以很好的跟踪一个事件,并对其进行度量,以提供丰富的分析能力.然后当需要一些状态度量时,比如账户余额,买卖家星级,产品库存,卖家累计交易额等等,则需要聚集与之相关的事务才能进行识别计算;或者根本无法识别计算.对于这些库存类的状态度量,事务事实表是无效率的.遇到这类事实来说,就要采用周期快照事实表在确定的时间内对该事实进行快照记录,而不需要聚集长期的事务历史.

* 快照粒度通常总是被多维声明.可以简单的理解为快照需要采样的周期以及什么将被采样.快照周期不一定都按天来进行,也可以按照月或者季度来统计,同时其他维度也可能不同.
* 周期快照事实表是稠密的.事务事实表是稀疏的,只有当天发生了业务过程才会被记录到业务过程的事实表中,而周期快照事实表是稠密的,无论当天是否有业务过程发生,都会在周期快照事实表中记录一行.
* 周期快照事实表的度量是半可加的.一般不能用时间维度进行汇总,但是可以平均.
* 事务事实表和快照事实表往往都是成对设计的,相互补充,以满足跟多的校友统计分析需求.

#### 周期快照事实表设计步骤
1. 确定快照事实表的快照粒度.一般都是以天为单位进行快照.一行代表一天.
2. 确定快照事实表的维度.
3. 确定快照事实表采样的状态度量.

> 一般在确定了快照周期后,需要确定一些其他相关维度.当确定了所有维度后,度量就会很明显了.例如:采用周期为天,相关维度为:买家/卖家/商品/类目/地区等,可以计算的度量就有累计的交易金额,交易单量等等.
> 

![周期性快照事实表示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/周期性快照事实表示例.jpg)


#### 累计快照事实表设计
* 在面对以流程为单位的需求时,事务事实表很难满足.因为事实事实表仅仅是流程中的单个业务过程.如果要用事实事实表进行统计则需要将整个业务过程连接成一个整体流程.逻辑复杂且性能很差.这个时候要采用累积快照事实表来解决这种无固定周期的短时间流程的事务.
* 累计快照事实表数据是不断更新的,直到整个流程事务完成为止.
* 累计快照事实表中包含多个业务过程日期,用于计算业务过程之间的时间间隔.
* 累计快照事实表保存的是全量数据.每天全量更新.

#### 累积快照事实表设计过程
* 累积快照事实表设计过程跟事务事实表设计过程一样,适用于维度建模.

1. 选择业务过程.

> 累积快照事实表关系的是整个流程,而整个流程中包含了多个业务过程.我们要选择出需要关注的业务过程.例如:订单流转这个流程中包含了很多业务过程,我们比较关注的是买家下单/买家付款/卖家发货/买家确认收货四个子业务过程.
>
> 一般对于订单流转这类流程,订单都是会有各自的状态的,每个状态变更都代表了一个业务过程,所以有时候在建立累计快照事实表的时候一般会按照流转状态来表示子业务过程.如果涉及好一个有开始和结束的完毕的流转状态模型,那么累计快照事实表通过采用状态表示业务过程可以解决任何的非线性的业务过程流转问题.

2. 确定粒度

> 找出流程中的公共原子粒度.例如:订单流转过程中粒度应该为子订单.

3. 确定维度

> 应该汇总整个流程中涉及到的所有维度.同时还要将各个业务过程发生的里程碑时间以退化维度记录到事实表中.

4. 确定事实

> 对于累计快照事实表,需要将各个业务过程对应的事实均放入事实表中.因为累计快照事实表解决最重要的问题就是统计不同业务过程之间的时间间隔,建议将每个过程的时间间隔作为事实放在事实表中.

5. 退化维度

#### 累计事实表的物理存储问题

1. 全量表的形式
	* 全量表一般为日期分区表,每天的分区存储昨天的全量数据和当天的增量数据合并的结果.如果数据量很大,全量数据表数据不断膨胀,存储了大量永远不会再更新的历史数据,对于性能影响很大.
	* 全量导入,不采用日期分区.每天全量更新,虽然减少了不会更新的历史数据存储,但是不更新的历史数据参与计算,对于计算性能也是有一定影响的.

2. 全量表的变化形式
	* 较短生命周期的业务实体一般从产生到消亡都会有一定的时间间隔,可以测算这个时间间隔.在时间间隔内的数据我们视为可能未消亡.仅仅保存在时间间隔以内的数据.例如:以200天为消亡时间间隔.我们每天存储近200天的交易订单,而200天以前的订单分开进行存储在归档表中.

3. 以业务实体的结束时间分区
	* 每天的分区仅仅存放当天结束的数据,对于非结束的业务实体则存储在一个设计时间比较大的分区,例如 9999-12-31.由于每天将当天结束的分区归档到当天分区中,时间非常大的未消亡的业务实体数据量不会很大.在计算新的一天变更数据的时候直接采用未归档的数据然后计算更新,把更新后消亡的订单放入当天的归档分区,ETL性能很好,并且无存储的浪费,对于业务实体的某个具体事例,在该表的全量数据中唯一.

#### 聚集性事实表
* 聚集性事实表是通过汇总明细粒度数据来获得改进查询性能的效果.通过访问聚集数据,可以减少数据库在响应查询是必须执行的工作量,能够快速响应用户的查询,同时有利于减少不同用户访问明细数据带来的结果不一致问题.

#### 聚集性事实表基本原则
* 一致性.聚集表必须提供与查询明细粒度数据一致的查询结果.确保一致性,最简单的方法就是确保聚集星型模型中的维度和度量与原始模型中的维度和度量保持一致.
* 避免单一表设计.不要在同一表中存储不同层次的聚集数据.例如在同一张聚集表中存储按天汇总的交易额,按月汇总的交易额,将会误导使用者产生误用导致重复计算.为了避免这个问题,通用的做法是在聚集时显示的加入数据层级统计周期来进行区别.<聚集主体>_时间标识
* 聚集粒度可不同.聚集并不需要保持与原始明细粒度数据一样的粒度.聚集事实表中的维度也是与一致性维度直接关联的.只关心所需要查询的维度.
* 不要跨数据域和事实.聚集的维度和度量必须与原始模型保持一致,聚集是不跨事实表的.就是说,同一张事实表所有维度cube存在该事实表的聚集事实表下,不能进行跨事实表的交叉聚集.如果要很想钻取多个事实表基于一致性维度分析,之前要做事实表的融合.
* 在设计聚集事实表时尽量要沉淀出通用的聚集事实.

#### 聚集的基本步骤
1. 确定聚集维度
2. 确定一致性上钻:按照什么维度进行汇总,日期维度+其他维度
3. 确定聚集事实

> 例如:按照商品粒度汇总
> 
> 1. 确定聚集维度:商品
> 
> 2. 确定一致性上钻:按照商品ID最近1天汇总
> 
> 3. 确定聚集事实: 下单量和交易额
> 
> 如果步骤2出现这种不同层级的需求:最近1天下单量和最近7天成交单量,尽量避免放在同一个聚集表中,如果放的话需要使用表示区分 order_num_1d/deal_order_num_7d.
