# 数据仓库工具箱笔记
## 前言

* 这本书是维度建模的权威指南,但是由于书写的时间比较早,随着技术的不断更迭有些内容以及不适用了.不讨论当时技术在现在是否还适用,仅仅当经典概念来学习.
* 书中内容是根据不同的业务场景来逐步介绍维度模型的,这里总结就不按照书中的结构来记录了,仅仅记录自我认为比较合适的概念.
* 声明:本人是实习生,水平真的有限.酌情阅读,有理解错误欢迎指出.


## 基本概念了解

[基本概念](https://my.oschina.net/leejun2005/blog/188770)

## 1.初步认识 

### 数据获取和数据分析的区别

* 操作型系统保存数据;DW/BI使用数据.
* 操作型系统目的是更快的处理单个事务;DW/BI目的是更快的完成多个事务分析.
* 操作型系统不维护历史数据,只反映最新状态;DW/BI保存维护历史数据.

### 数据仓库的目标

* 易用性:简单,快捷.

> DW/BI系统的数据的内容易于理解,具有直观性,较短时间内将分析查询数据返回给用户.

* 一致性:数据必须就有一致性,具有一致性后才具有可信度.

> DW/BI系统的数据往往来自不同的数据源,需要进行一致性集成.

* 可变性:能够适应需求的变化.

> DW/BI系统要能够方便处理需求的无可避免的变化,在发生变化的时候仍能提供数据服务

* 支持决策:正确的支持决策.

> DW/BI最重要的输出是基于分析证据所产生的决策.注意,面向决策和面向财务的不同,面向决策是在一定程度上允许有误差的,面向财务则必须时刻准确.


### 维度建模简介

* 维度建模面向数据分析.
* 数据库中强调3NF,主要为了消除冗余.维度模型并不要求必须满足3NF.

#### 3NF模型和维度模型的区别

* 3NF模型
	* 规范化的3NF将数据划分为多个不同的实体,每个实体构成一个关系表
	* 大幅度减少数据冗余
	* 复杂度高,难以理解
	* 查询性能低
* 维度模型
	* 复杂度低,易于理解
	* 查询性能高
	* 灵活多变

#### 用于度量的事实表

* 事实表存储业务过程时间的性能度量结果.
* 尽量将来源于同一个业务过程的底层度量结果存储于一个维度模型中.
* 事实表示某个业务的度量.
* 事实表中的每行对应一个度量事件,同一张事实表中的所有度量行粒度相同.
* 度量数值类型
	* 可累加型事实,例如:销售额,可按照任意时间维度进行汇总.
	* 半可累加型事实,例如:账户余额,不能按照时间维度进行汇总,可按照时间均值.
	* 不可累加型事实,例如:单价.完全不能按照时间维度来做处理.
* 尽量不要将冗余文本信息(除唯一文本)放在事实表中,描述性冗余文本信息放入维度表中.对于事实表中的每个行来说,其文本都是唯一的.
* 不要将未发生的度量时间存入事实表.
* 事实表列少行多.
* 事实表类型
	* 事务型事实表
	* 周期快照型事实表
	* 累计快照型事实表
* 一般事实表具有多个外键与维度表的主键进行关联.
* 几个维度一起唯一标识一个事实表行.

#### 用于描述环境的维度表
* 维度表示度量时间的描述性信息.
* 维度表包含业务过程度量事件有关的文本环境.
* 维度表列多行少.
* 每个维度表由单一主键定义,用于在于事实表连接时作为参照完整性的基础.
* 数据库完整性:保证数据一致性,正确性,有效性
	* 参照完整性:要求关系中不允许引用不存在的实体.保证数据一致性和完整性.
	* 实体完整性:每个数据表必须有主键,唯一且非空.保证数据非空/唯一.
	* 域完整性:列必须满足某种特定的数据类型或约束.用户定义的完整性.
* 维度模型直接决定了数据仓库的好坏和OLAP的分析能力.
* 维度表通常具有层次关系,例如:日-周-月-年.这样做的目的是方便使用和提高查询性能.维度表通常不一定要满足第3范式,它常常是非规范化的,一个维度表往往存在多对一的关系.

#### 如何区分是维度还是事实?

* 描述性列
	* 该列数据是一种包含多个值并作为计算的参与者的度量,往往是事实.
		* 例如:产品的标价看起来像是一个产品的描述,但是它经常会发生变化,并且需要参与最终订单支付金额的计算,所以更可能是一种度量事实.
	* 该列是对具体值的描述,是一个常量/约束/行标识的参与者,往往是维度.
* 数字量
	* 连续值数字基本上可以任务属于事实.
	* 来自一个不太大的列表的离散数字基本可认为是维度属性.

#### 如何选择粒度

* 粒度最小的数据或原子数据具有最多的维度.尚未聚集的原子数据是最具有可表达性的数据.原子数据是构建能够满足用户提出任意查询的事实表的设计基础.同时也方便添加维度信息.

## 2.维度建模技术概要

### 4步骤维度设计过程
1. 选择业务过程:明确事实表要度量的事件是什么?
> 业务过程是由组织完成的微观活动.
> 
> 例如:获取订单,开具发票,学生注册,账户快照等
	* 业务过程特征
		1. 业务过程通常用行为动词表示,通常表示业务执行的活动
		2. 业务过程建立或获取关键性能度量
			* 建立关键性度量:学生注册,开具发票等
			* 获取关键性度量:获取订单,账户快照等
		3. 度量是业务过程的直接结果
		4. 一系列过程产生一些列事实表.

2. 声明粒度:定义事实表的每一行表示什么?
> 声明粒度意味着精确定义某个事实表的每一行表示什么.
> 
> 粒度传递的是与事实表度量有关的细节级别.
> 
> 例如:销售事务上每个销售订单一行,每个银行账户每个月一行.
	* 声明粒度是不容忽视的关键步骤,在构建维度模型前必须明确定义维度模型的粒度.
	* 粒度分为
		* 原子粒度
			* 能满足方便详细的维度建设
			* 能满足任何分析需求
			* 但是查询性能差
		* 聚合粒度
			* 限制了细节维度的建设
			* 无法下钻,分析有障碍
			* 查询性能好
	* 声明粒度最好以最低的原子粒度为基准.因为原子粒度具有强大的多维性
	* 也可以定义汇总粒度来表示对原子数据的聚集,但是一旦选择较高粒度就限制了建立更细节的维度的可能性,无法满足用户的下钻细节的需求.
	* 原子粒度和聚合粒度并不是互斥关系,可以构建原子粒度的企业一致性模型,然后在这基础上构建聚合粒度的模型.

3. 确认维度:怎么描述业务过程度量事件?
> 维度表示承担每个度量环境中所有可能的单值描述符.
> 
> 应当使用健壮的维度集合来描述事实表.
> 
> 常见的维度有:日期,用户等.

4. 确认事实:过程的度量是什么?
> 确定事实表度量的指标.
> 
> 设计中多有获选事实必须符合第2步粒度的定义.
> 
> 明显不同粒度的事实必须放在不同的事实表中.

![维度设计4步过程的关键输入](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/4步建模.jpg)

### 维表设计细节

> 维度提供围绕某一业务过程事件所涉及的"谁,什么,何处,何时,为什么,如何"等背景.

* 维度表包含BI应用所需要的用于过滤及分类事实的描述性属性.
* 当与事实表行关联时,任何情况下都应使维度保持单一值.
* 原子粒度维度模型对数据关系发生变化具有灵活的适应性.

#### 维度表代理建
* 维度表的唯一主键应该是代理建而不是来自操作型系统的标识符,也就是所谓的自然键.
* 代理键简单地以按照顺序序列生成的递增整数表示.
* 实际上代理键没有业务上的意义,仅仅用于连接维度表与事实表.
* 在做查询和数据访问应用时,不应该有任何与键的依赖关系.
* 使用代理键好处
	* 为数据仓库缓冲操作型系统的变化
	* 可以集成多个数据源
	* 改进性能:代理建是一个尽可能小的整数,而自然键则可能是庞大的数字/字母集合
* 使用代理键缺点
	* 生成费事,不如自然键直接使用方便
* 代理建生成

```sql
	#当前行号加上之前维度表的最大行数
	
	select row_number() + max_id, ... -- 因为代理建是简单递增,直接添加
	from ... t
	join(
		select max(id) as max_id from table
	) s --这里采用cross join
	
```

* 时间维度的智能键
	* 时间维度是可以预测的,所以可以在日期维度中使用更为智能的键
	* 日期维度的主键是一个有意义的整数

> 最好将时间维度的代理键设置为格式为YYYYMMDD.在事实表中,可以采用日期维度的外键进行过滤,提高过滤的可用行和性能.同样还可以将日期维度的智能键用于分区事实表,分区去报能够将表划分为更小的表.

* 通常不会给退化维度分配代理建.
* 事实表主键与维度表代理键不同,事实表主键采用代理建不可能获得查询性能的改进.所以一般事实表不采用代理建作为主键,采用直接的唯一标识即可.

#### 扁平多对一层次
* 维度表中每个不同层次都存在多对一关系,并且以扁平的形式存在于维度表中.

![产品维度示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/产品维度示例.jpg)

> 上图是产品维度的示例.产品维度描述仓库中存储的每个SKU(产品统一编码)的大多数描述性属性.每个属性都可以有层次.例如,图中每个SKU可以上卷到品牌,每个品牌可以上卷到类别,每个类别可以上卷到部门.每个不同层次都存在多对一的关系.(多个SKU对应一个层次).
> 
> 注意到商品维度的设计不是规范化的.例如,产品5-8子类描述全是Ice Cream.是不是设计错了?并不是这样.

#### 非规范化
* 维度表是带有重复文本的扁平非规范化的设计.
* 非规范化坏处
	* 数据冗余度高
	* 异常插入:新加入一个品牌但是没有SKU,就不能添加到表中你
	* 异常删除:删除一个SKU可能将该品牌值删光
	* 异常更新:每次更新都要更新多行
* 为什么维度表要设计成非规范化?
	* 对于事实表,维度表很小,数据规范节省空间效果甚微.
	* 非规范化值容易实现简单化与高性能
	* 维度模型主要关注易用性和性能的价值,而不是关注事务处理的效率

> 非规划化的缺点其实都是面向操作型系统的.操作型系统关注的是事务处理的速度,所以着重优化事务处理的过程.而维度表则关注的是数据分析,所以非规范化带来的异常增删改并没有对分析造成影响.在数据冗余方面,虽然非规范化带来的了少许数据的冗余,但是是可以接受的.相比较规范化导致分析数据的性能低和随之而来的抽象性,还是选择非规划化比较明智.

##### 具有规范化维度的雪花模型
* 规范化的维度表称为雪花模型.
* 冗余属性从扁平非规范化维度表中移除,放置于不同规范化的维度表中.

![产品维度雪花模型示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/产品维度雪花模型示例.jpg)

> 上图是产品维度雪花模型的实例,我们通过看图观察发现
> 
> 1.众多的雪花模型表构成了一个复杂的结果,违背了维度建模简单化的主要目标.
> 
> 2.大量的表和连接操作通常导致缓慢的查询性能.
> 
> 3.与雪花模式维度表有关的磁盘空间节省问题并不是非常明显.通过规范化维度表所节省的磁盘空间通常不会超过数据所需要空间的1%,
> 
> 4.雪花模式对用户浏览维度的能力有负面影响.

* 雪花模型虽然不推荐使用,但是也是维度建模的一个合法分支.
* 提倡采用固定深度层次在维度表中应该被扁平化,而不是规范化,牺牲掉规范化的冗余数据空间有利于改善性能和可用性.所谓用 空间 -> 易用性,性能

##### 雪花模型一部分的支架表
* 尽管不推荐使用雪花模型,但是在一些场景下是可以使用的.
* 但是不是意味着将整个模型规范化,而是将其中某个扁平化的多对一的层次规范化成支架表.

![产品维度支架表示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/产品维度支架表示例.jpg)

> 上图是产品维度日期支架表的示例

#### 属性层次
* 层次就是一系列多对一的关系.
* 层次分为
	* 固定层次
		* 例如日期层次: 天 -> 月 -> 年
		* 在固定位置的维度中,重要的是每个层次具有特定的名称,用户一看就知道如何约束并解释每个层次.应该避免在固定位置层次中使用抽象的名称.例如:级别1,级别2.
	* 非固定层次
		* 轻微不整齐的可变深度层次
			* 没有固定的层次深度,但层次深度有限
			* 例如:地理层次:地址 -> 区域 -> 城市 -> 省份,这里的区域是可以包含层级的,一级区域,二级区域...,
		* 不整齐可变深度层次
			* 深度不确定
			* 例如:公司组织结构
* 如何处理非固定层次问题
	* 轻微不整齐可变深度层次:合并微可变层次变成固定层次.例如:将所有区域放在一起当做一个区域层次.
	* 不整齐可变深度层次:建立桥接表

![组织桥接表示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/组织桥接表示例.jpg)

> 上图是组织桥接表的一个简单示例.在大公司组织中往往会存在不固定的上下部门组织之间的关系.在维度表中一个组织肯定对应一个层次.我们没有办法确定层次个数,所以只能采用桥接表的形式来辅助记录层次关系.我们看到事实表的组织外键并不是直接连到组织维度的代理键上,而是连接到桥接表.桥接表中记录了父子部门的层间关系(树形关系),以及所在位置信息,桥接表中的部门键才指向组织维度表.

* 如果,桥接表存在缓慢变化问题,我们可以采用维度缓慢变化的解决方式来解决.

![组织桥接拉链表示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/组织桥接拉链表示例.jpg)

> 上图是采用类型2来解决桥接表的变化问题.类似拉链表,添加上了生命周期.注意,生命周期结束的日期往往是下一个生命周期开始的日期,而不是真实结束的日期.为什么这么做?因为如果要是真的关注真实结束日期的话,就需要时时刻刻关注,一旦变化就更新桥接表.这样做即浪费时间还耗费精力,数据精度也没有提高多少.

#### 作为属性或事实的数字
* 某些数字值,很难判断应该将其归入维度属性分类,还是归入事实分类.

> 例如:产品的价格,因为商品的价格通常变化缓慢,不像其他事实表中的数量值,对一不同度量事件产生不同的值.那么商品价格是维度吗?

* 如果某个数字值主要用于计算或分析目的,他可能应该属于事实表.
* 如果某个数字值主要用于标识,分组,约束,他可能应该属于维度表.
* 如果数字值可同时用于计算以及过滤/分组功能,应该在事实表和维度表中同时存储.

> 标准价格主要用于计算最终订单支付总金额,或主要用于分析该商品的价格变化应该被存储在事实表中.如果能预先定义稳定的数字值,用于过滤和分组,则它应该被当成产品维度属性对待.如果标准价格同时被存储在事实表和维度表中,事实表中表示的是销售事务的价格,而维度属性则标识为指示当前情况的标准价格.

#### 维度的扩展
* 以最细粒度级别构建的维度,增加的维度可方便的应用,不必改变维度键或事实.
* 过早的聚集和汇总限制了增加补充维度的能力.
* 扩展能力
	* 新维度属性:可以把新属性作为新列增加进去.如果新属性仅在某个特定时间点可用,在老的维度行中将插入不可用或类似的描述.
	* 新维度:可在事实表上增加新维度,在事实表上增加新的外键列并将新维度的主键填写到该外键列上
	* 新可度量事实:如果新的可度量事实可用,可以将他们方便的增加到事实表上.事实表被改变,增加了新列,值被填充至表中.如果新事实仅在某个时间点可用,则将空值填充到旧事实表行中.
* 注意:粒度不同,不能进行到同一张表中.所以具有原子粒度的表是扩展性最好的表.

#### 日期维度
* 日期维度是一种特殊的维度,因为它几乎出现在所有的维度模型中.每个业务过程都需要获取时间序列的性能度量.
* 日期维度表示粒度按天处理的维度表,也就说时间维度的力度是天.
* 与多数其他维度不同,可以提前建立日期维度表.
* 日期维度表是相对较小的维度表.
* 日期维度表中的每列由行表示的特定日期定义.
* 日期维度的主键是特殊的智能主键,最好采用YYYYMMDD形式的整数格式.
* 日期维度可以包括过去和未来的日期.

![日期维度简单示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/日期维度简单示例.jpg)

> 上图是日期维度的简单示例.

* 为什么要有日期维度?
> 存在疑问的原因在于,如果事实表上的日期是日期类型的列,任何SQL查询可以直接约束事实表的时间键,利用SQL提供的日期语义进行过滤,从而可避免连接操作带来的使用性能.
>
> 但是,SQL日期函数不能支支持范围广泛的日期属性,包含周/财务周期/季节/假日/周末等等,与其试图将这些非标准日历计算放入查询中,不如放在日期维度表中,通过查询直接获得.日历逻辑由维度表解决,而不是由应用代码解决.所以,日期维度应尽可能的详细,维度模型也总是需要详尽的日期维度表.

* 大多数日期维度属性不应该更新.
* 大多数数据仓库按天加载数据.
* 最好以天为时间维度的粒度,如果需要精确的时间,应该用过时间戳来完成.
* 如果不需要对日期进行复杂的操作,可以退化放在事实表中.

#### 退化维度
* 操作型事务控制号码通常产生空的维度并且表示为事务事实表中的退化维度.
	* 例如:订单号码,发票号码,提货单号等.
* 当事实表粒度表示单一事务或事务列表时,退化维度比较常见.
* 退化维度通常在事实表的主键中起着重要的作用.
* 退化维度是没有对应维度表的维度键.
* 退化维度通常被保留作为操作型事务的标识符.

> 当一个维度值在不同事实中产生不同的度量,可以将该维度退化成为退化维度.

* 为什么要将事务单一的维度退化成为事实呢?
	* 因为维度表不应该与事实表一样以同样的速率增长.

#### 杂项维度
* 在建模复杂的操作型数据时,通常会遭遇大量五花八门的指标和标志,它们包含小范围的离散值.例如:支付类型.处理这些标志和指标的适当方法是将他们包装为一个或多个杂项维度.
* 杂项维度是对低粒度标志和指标的分组.
* 通过建立杂项维度,将标志和指标从事实表中移除,并将它们放到有用的多维框架中.
* 杂项维度可提供地方用于基于这些表示的约束和报表.事实与杂项维度之间存在一个单一的,小型的代理建.

![杂项维度示例](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/杂项维度示例.jpg)

> 上图是杂项维度的示例.支付类型/支付类型分组/订单类型等都是具有可数个数的标识维度.如果单独作为一个维度太小.所以进行合并成为杂项维度.一个完全的杂项维度是每个标识维度之间的笛卡尔积.

* 关于杂项维度的一个问题是:是否应该事先为所有组合的完全笛卡尔积建立行
 	* 应该估计杂项维度大概有多少种组合
 		* 组合数少时,可以预先建立起全完的杂项维度
 		* 组合数多时,当遇到未保存的杂项维度组合时新增杂项维度行.

#### 维度表的空值属性
* 当给定维度行没有被全部填充时,或者当存在属性没有被应用到所有维度行时,将产生空值维度属性.这种情况下,推荐采用描述性字符串代替空值.例如:Unknown,Not Applicable替换空值.
* 应该避免在维度表中使用空值.建立空值的维度行,用于处理无维度情况.

#### 处理缓慢变化维度(SCD)属性
* 尽管维度表属性相对稳定,但它们不可能是一成不变,尽管相当缓慢,属性值仍然会随时间发生变化.
* 缓慢变化维度(Slowly Changing Dimension,SCD)

##### 类型0:保留原始值
* 标记位类型0的维度属性值绝对不会变化,因此事实始终按照该原始值分组.
* 类型0适合任何标记位原始的属性,例如原始信用分值等历史不会发生变化的维度信息.

##### 类型1:重写
* 对缓慢变化维度类型来说,对其影响需要重写维度行中的就值,以当前值覆盖替换.
* 属性始终反映最近的情况.
* 类型1响应是应对维度变化的最简单的方法.
	* 仅需要以当前值重写先前存在的值.
	* 不需要触碰事实表.
* 类型1存在的问题是将会失去属性变化的所有历史记录,因为重写删除了历史属性值,仅保存了当前最新的属性值.
* 适用于对属性变化并不是很在意或不需要保存过去的描述的场景.
* 类型1响应易于实现,但是无法保留属性值的历史值,违背了数据仓库的一个特性:反映历史.在属性变化前后可能会产生不同的结果.
* 在维度发生变化的时候,收到影响的的聚集表需要重新组织重写.

##### 类型2:增加新行(拉链表),反映历史变化
* 使用类型2方法,在维度发生变化时,新的维度行将被插入到维度表中应对维度变化.

![缓慢维度变化问题-类型2](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/缓慢维度变化-类型2.jpg)

> 上图是用类型2来解决维度变化问题.在示例中,因为部门名称发生变化,则新建立一行最新的数据维度行插入到原表中.

> 当维度表包含类型2属性时,应该为每行增加几个方便管理的列.生命周期指示行:生命周期开始时间,生命周期结束时间.添加时间.当前行是否有效指示标志.
> 
> 有效日期和失效日期支持对维度的精确的时间分片.有效日期行是描述事务有效的第一天.当首次加载到维度表时,失效日期被设置为9999-12-31,应该避免失效日期为空值.
> 
> 当新行添加到维度表中以获取类型2属性变化时,先前的行过期了,通常建议旧行的结束日期等于新行的有效日期,不要在这些有效日期和失效日期间留下时间间隔.通常,有效日期和失效日期通常表示变化是按天度量的.如果要跟踪更细的时间粒度应该关注与该行的添加和更新时间戳.

* 缓慢变化维度类型2响应需要使用代理键,而不是自然键.
* 发生类型2变化时,事实表仍没有被改变;不需要修改历史事实表行,只需要在新维度变化后的事实中引用新维度的代理键即可.
* 类型2响应是**精确跟踪缓慢变化维度属性**的主要技术.因为新维度行能够自动划分事实表的历史,这是一种非常好的技术.
* 类型2可以说是拉链表.具体拉链表的使用请见[拉链表简介](https://blog.csdn.net/xiepeifeng/article/details/42431027)  [拉链表ETL](http://lxw1234.com/archives/2015/08/473.htm)

##### 类型3:增加新属性,反映历史关联
* 类型2响应能够区分历史情况,但是无法确保能够将新属性值与过去的历史事实关联.因为类型2在事实使用新的维度属性的时候并没有对旧属性的相关记录.

> 类型2无法解决这样的需求:当销售地区边界被重新划分.对新的销售地区维度采用类型2的解决方式.有些用户希望能够按照先前地区上卷最近的销售情况,以观察对比新的的地区的销售情况.

* 维度发生变化前后新旧值,使用类型3响应的话,不需要建立新维度行,仅需要增加新列以获取属性变化.

![缓慢维度变化问题-类型3](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/缓慢维度变化-类型3.jpg)

> 上图是类型3的示例,在部门名称发生变化时,需要更改维度行中的当前部门名称和先前部门名称,不需要添加新的维度行.

* 类型3缓慢变化维度技术能够确保要么通过新的,要么通过旧的属性值来考察新的事实表和历史事实表,有时候也被成为交换的现实.
* 类型3很少被使用,因为不能够解决不可预测的属性变化.
* 类型3最时候应用于当某个变化影响维度表中大量行(整体维度重构)的情况,例如部门重组.整体发生变化是使用类型3的主要场景,因为业务用户通常希望能够比较当前和先前层次下组织在一段时期的度量.采用类型3变化,先前列将被标记以明显地表示变化前的分组.

##### 类型4:微型维度,解决维度快速变化
* 上面我们关注的是维度表的缓慢变化的问题,如果变化率加快时,特别是针对大型的维度表如果采用类型2则会产生巨大的维度表.这类维度的容量对浏览和查询性能具有负面影响.我们不希望在包含大量行的维度表上增加更多的行,特别是面对变化频繁发生的情况.
* 采用不同的维度消除频繁分析或频繁变化的属性,这一维度技术称为微型维度.
* 微型维度的创建时通过将一部分不稳定的属性从主维度中移出,并将他们放置到拥有自己代理键的新表中来实现的.这些属性相互之间没有直接关联,不存在自然键,是通过为每个组合创建新行的一次性过程来加载数据的.

> 用户维度中,用户的注册日期/性别/身份证/年龄等属性是基本上不会发生变化的.但是用户VIP等级/用户信用等级会随着用户的行为不断发生变化.将容易发生变化的属性从主维度表中移出,放到一个新的维度表中.新的维度表中的数据行并不是每个用户一行,而是按照移出的维度属性的所有枚举值进行笛卡尔积加载而成的.新的维度表中并没有自然键,也不能使用自然键,应该使用代理键.

* 微型维度具有局限性.微型维度是事先用所有可能值的组合加载的,需要考虑每个属性的基数,且最好是枚举值.很多属性可能是非枚举值也同样变化很快.
* 微型维度虽然很少的保证了主维度的稳定性,但是破坏了维度的可浏览性.

> 如果是非枚举值,可以将不断变化的属性转化为带状范围值.宽度范围集合需要与业务人员商量进行预先制定,这样能够将未知且离散的属性值转化为已知的范围值存储,还能大大减低微型维度的大小.
> 
> 注意:微型维度一般都是提前建立好的.

![带状微型维度](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/带状微型维度.jpg)

* 注意:微型维度虽然是在大维度表中抽取出来的不稳定维度,但微型维度并没有与大维度表进行关联,而是与事实表进行关联.如果与大维度表进行关联同样没有解决维度变化过快问题,只是简单的将维度分开.如果与事实表关联则是将微型维度里的维度视为'退化维度'处理,事实表的增长则不会影响到大维度表,因为变化的属性值被分开到微型维度,而微型维度中也没有随着事实表增长而增长,因为是枚举组合,直接应用可能值的代理键即可.

![微型维度](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/微型维度.jpg)

##### 分区解决维度变化

* 这是询问公司大佬,他们原公司的解决方式.每天都全量导入维度表.每天一个分区.如果有相关历史维度需求则可以联合使用分区数据来完成.但是这种方式实现简单,使用方便,但是存在的问题是变化维度固定为天,一些精细的历史变化分析需求无法满足.

#### 维度角色扮演
* 当同一维度同时被当成单一事实表中的不同角色,这种情况成为角色扮演.
* 当某个维度在单一事实表中同时出现多次时,则会存在维度模型的角色扮演.
* 基本谁度可能作为单一物理表存在,但是每种角色应该被当成标识不同的视图展现到BI工具中.

![日期维度角色扮演](https://github.com/zzhangyuhang/The-Data-Warehouse-Toolkit/blob/master/photo/日期维度角色扮演.jpg)

> 上图是日期维度角色扮演的实例,日期维度被当做两个角色与事实表进行关联.与日期维度来说,订单日期维度和请求发货日期维度是根据日期维度建立的不同名字的视图.



### 事实表设计细节

#### 事实表结构
* 从最低的粒度级别来看,事实表行对应一个度量事件.
* 事实表的设计完全依赖于物理活动,不受可能产生的最终报表的影响.
* 除数字度量外,事实表总是包含外键,用于关联与之相关的维度,也包含可选的退化维度键和日期/时间戳.

#### 可加/半可加/不可加事实
* 事实表中的数字度量可划分为三类
	* 可加性度量:可以按照与事实表关联的任意维度汇总.最灵活,最有用的的事实是完全可加的.
	* 半可加度量:可以对某些维度汇总,不能对所有维度汇总.例如库存,可以按照地点和商品进行汇总,而按照时间维度把库存累计起来则毫无意义.记录静态水平(库存水平,金融余额)的所有度量针对日期维度天然居委非可加性.在此情况下,度量可以跨日期按照时间周期**求平均**来聚集.
	* 不可加事实:完全不可加的,例如比率.对于不可加的事实尽量将不可加性事实可分解为可加性事实.不可加事实通过分解的事实进行计算.例如优惠率,应该分解为订单原价金额与订单优惠金额两个事实存储在事实表中.

#### 事务事实表
* 事实事实表的一行对应空间或时间上某点的度量事件.
* 事务事实表可以是稠密的,也可以是稀疏的,仅当存在度量时才会建立行.
* 度量数字事实必须与事务粒度保持一致.
* 事务型业务过程是最常见的业务过程.
	* 原子事务事实表的粒度可在事务环境下简洁的描述,每个事务一行或每个事务线一行.
	* 通常比较稀疏,事务事件发生时间随机.
	* 可能十分庞大
	* 事务事件返回的度量通常都是可加的
* 设计事务事实表之前,估计事实表的行数是非常有必要的.

#### 周期性快照事实表
* 周期快照事实表中的每行汇总了发生在某一标准周期,如某一天/某周/某月的多个度量事件.
* 粒度是周期性的,而不是个体的事务.
* 周期快照事实表通常包含许多半可加事实,任何与事实表粒度一致的度量事件都是被允许存在的.
* 周期性快照事实表是稠密的,即使周期内没有活动发生,也会在事实表中为每个事实度量插入包含0的行.
* 周期性快照事实表的事实是根据时间周期和业务选定维度来确定度量的.只要周期和维度一致即可存在于一个快照性事实表中.